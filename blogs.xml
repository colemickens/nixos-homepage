<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
	<title>NixOS Planet</title>
	<link>https://planet.nixos.org</link>
	<language>en</language>
	<description>NixOS Planet - https://planet.nixos.org</description>
	<atom:link rel="self" href="https://planet.nixos.org/rss20.xml" type="application/rss+xml"/>

<item>
	<title>Cachix: Documentation and More Documentation</title>
	<guid isPermaLink="true">https://blog.cachix.org/posts/2020-07-20-documentation-and-more-documentation/</guid>
	<link>https://blog.cachix.org/posts/2020-07-20-documentation-and-more-documentation/</link>
	<description>Documentation is an important ingredient of a successful software project.
Last few weeks I’ve worked on improving status quo on two fronts:
1) https://nix.dev is an opinionated guide for developers getting things done using the Nix ecosystem.
A few highlights:
 Getting started repository template with a tutorial for using declarative and reproducible developer environments
 Setting up GitHub Actions with Nix
 Nix language anti-patterns to avoid and recommended alternatives</description>
	<pubDate>Mon, 20 Jul 2020 14:45:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Tweag I/O: Setting up Buildkite for Nix-based projects using Terraform and GCP</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-07-08-buildkite-for-nix-ci/</guid>
	<link>https://tweag.io/blog/2020-07-08-buildkite-for-nix-ci/</link>
	<description>How to setup a Buildkite-based CI for Nix projects with workers running on GCP.</description>
	<pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Nix Flakes, Part 2: Evaluation caching</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-06-25-eval-cache/</guid>
	<link>https://tweag.io/blog/2020-06-25-eval-cache/</link>
	<description>How Nix flakes enable caching of evaluation results of Nix expressions.</description>
	<pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: Automatic Resource Optimization</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-06-25-automatic-resource-optimization.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-06-25-automatic-resource-optimization.html</link>
	<description>&lt;p&gt;As of today, nixbuild.net will automatically select resources (CPU count and memory amount) for builds submitted to it. Based on historic build data, nixbuild.net calculates a resource allocation that will make your build as performant as possible, while wasting minimal CPU time. This means nixbuild.net users get faster and cheaper builds, while also taking away the user’s burden of figuring out what resource settings to use for each individual build.&lt;/p&gt;

&lt;p&gt;Previously, all builds were assigned 4 CPUs unless the user configured resource selection differently. However, configuring different resource settings for individual builds was difficult, since Nix has no notion of such settings. Additionally, it is really tricky to know wether a build will gain anything from being allocated many CPUs, or if it just makes the build more expensive. It generally requires the user to try out the build with different settings, which is time-consuming for a single build and almost insurmountable for a large set of builds with different characteristics.&lt;/p&gt;
&lt;p&gt;Now, each individual build will be analyzed and can be assigned between 1 and 16 CPUs, depending on how well the build utilizes multiple CPUs. The memory allocation will be adapted to minimize the amount of unused memory.&lt;/p&gt;
&lt;p&gt;The automatic resource optimization has been tested both internally and by a selected number of beta users, and the results have been very positive so far. We’re happy to make this feature available to all nixbuild.net users, since it aligns perfectly with the service’s core idea of being simple, cost-effective and performant.&lt;/p&gt;
&lt;h2 id=&quot;how-does-it-work&quot;&gt;How Does it Work?&lt;/h2&gt;
&lt;p&gt;The automatic resource optimization works in two steps:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;When a Nix derivation is submitted to nixbuild.net, we look for similar derivations that have been built on nixbuild.net before. A heuristic approach is used, where derivations are compared based on package names and version numbers. This approach can be improved in the future, by looking at more parts of the derivations, like dependencies and build scripts.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A number of the most recent, most similar derivations are selected. We then analyze the build data of those derivations. Since we have developed a secure sandbox specifically for running Nix builds, we’re also able to collect a lot of data about the builds. One metric that is collected is CPU utilization, and that lets us make predictions about how well a build would scale, performance-wise, if it was given more CPUs.&lt;/p&gt;
&lt;p&gt;We also look at metrics about the historic memory usage, and make sure the new build is allocated enough memory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
	<pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: Long-term reproducibility with Nix and Software Heritage</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-06-18-software-heritage/</guid>
	<link>https://tweag.io/blog/2020-06-18-software-heritage/</link>
	<description>How Nix is collaborating with Software Heritage for long-term software reproducibility.</description>
	<pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Mayflower: Windows-on-NixOS, part 2: Make it go fast!</title>
	<guid isPermaLink="true">https://nixos.mayflower.consulting/blog/2020/06/17/windows-vm-performance/</guid>
	<link>https://nixos.mayflower.consulting/blog/2020/06/17/windows-vm-performance/</link>
	<description>This is part 2 of a series of blog posts explaining how we took an existing Windows installation on hardware and moved it into a VM running on top of NixOS. Previously, we discussed how we performed the actual storage migration. In this post, we’ll cover the various performance optimisations we tried, what worked, and what didn’t work.
GPU passthrough Since the machine is, amongst other things, used for gaming, graphics performance is critical.</description>
	<pubDate>Wed, 17 Jun 2020 09:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Using Disnix as a simple and minimalistic dependency-based process manager</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-690526319663316035</guid>
	<link>http://sandervanderburg.blogspot.com/2020/06/using-disnix-as-simple-and-minimalistic.html</link>
	<description>In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/05/deploying-heterogeneous-service.html&quot;&gt;my previous blog post&lt;/a&gt; I have demonstrated that I can deploy an entire service-oriented system locally with &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; without the need of obtaining any external physical or virtual machines (or even Linux containers).&lt;br /&gt;&lt;br /&gt;The fact that I could do this with relative ease is a benefit of using &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html&quot;&gt;my experimental process manager-agnostic deployment framework&lt;/a&gt; that I have developed earlier, allowing you to target a variety of process management solutions with the same declarative deployment specifications.&lt;br /&gt;&lt;br /&gt;Most notably, the fact that the framework can also work with processes that &lt;a href=&quot;https://en.wikipedia.org/wiki/Daemon_(computing)&quot;&gt;daemonize&lt;/a&gt; and let foreground processes automatically daemonize, make it very convenient to do local unprivileged user deployments.&lt;br /&gt;&lt;br /&gt;To refresh your memory: a process that daemonizes spawns another process that keeps running in the background while the invoking process terminates after the initialization is done. Since there is no way for the caller to know the PID of the daemon process, daemons typically follow the convention to write a PID file to disk (containing the daemon's process ID), so that it can eventually be reliably terminated.&lt;br /&gt;&lt;br /&gt;In addition to spawning a daemon process that remains in the background, services should also implement a number of steps to make it &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/01/writing-well-behaving-daemon-in-c.html&quot;&gt;&lt;b&gt;well-behaving&lt;/b&gt;&lt;/a&gt;, such as resetting signals handlers, clearing privacy sensitive environment variables, and dropping privileges etc.&lt;br /&gt;&lt;br /&gt;In earlier blog posts, I argued that managing foreground processes with a process manager is typically more reliable (e.g. a PID of a foreground process is always known to be right).&lt;br /&gt;&lt;br /&gt;On the other hand, processes that daemonize also have certain advantages:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;They are &lt;b&gt;self contained&lt;/b&gt; -- they do not rely on any external services to operate. This makes it very easy to run a collection of processes for local experimentation.&lt;/li&gt;&lt;li&gt;They have a &lt;b&gt;standard means&lt;/b&gt; to &lt;b&gt;notify&lt;/b&gt; the caller that the service is ready. By convention, the executable that spawns the daemon process is only supposed to terminate when the daemon has been successfully initialized. For example, foreground processes that are managed by &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd&quot;&gt;systemd&lt;/a&gt;, should invoke the non-standard &lt;i&gt;sd_notify()&lt;/i&gt; function to notify systemd that they are ready.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although these concepts are nice, properly daemonizing a process is the responsibility of the service implementer -- as a consequence, it is not a guarantee that all services will properly implement all steps to make a daemon well-behaving.&lt;br /&gt;&lt;br /&gt;Since the management of daemons is straight forward and self contained, the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;Nix expression language&lt;/a&gt; provides all kinds of advantages over data-oriented configuration languages (e.g. JSON or YAML) and Disnix has a flexible deployment model that works with a dependency graph and a plugin system that can activate and deactivate all kinds of components, I realized that I could integrate these facilities to make my own simple dependency-based process manager.&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe how this process management approach works.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Specifying a process configuration&lt;/h2&gt;&lt;br /&gt;A simple Nix expression capturing a daemon deployment configuration might look as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{writeTextFile, mydaemon}:&lt;br /&gt;&lt;br /&gt;writeTextFile {&lt;br /&gt;  name = &quot;mydaemon&quot;;&lt;br /&gt;  text = ''&lt;br /&gt;    process=${mydaemon}/bin/mydaemon&lt;br /&gt;    pidFile=/var/run/mydaemon.pid&lt;br /&gt;  '';&lt;br /&gt;  destination = &quot;/etc/dysnomia/process&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression generates a textual configuration file:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;i&gt;process&lt;/i&gt; field specifies the path to executable to start (that in turn spawns a deamon process that keeps running in the background).&lt;/li&gt;&lt;li&gt;The &lt;i&gt;pidFile&lt;/i&gt; field indicates the location of the PID file containing the process ID of the daemon process, so that it can be reliably terminated.&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Most common system services (e.g. the Apache HTTP server, MySQL and PostgreSQL) can daemonize on their own and follow the same conventions. As a result, the deployment system can save you some configuration work by providing reasonable default values:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;If no &lt;i&gt;pidFile&lt;/i&gt; is provided, then the deployment system assumes that the daemon generates a PID file with the same name as the executable and resides in the directory that is commonly used for storing PID files: &lt;i&gt;/var/run&lt;/i&gt;.&lt;/li&gt;&lt;li&gt;If a package provides only a single executable in the &lt;i&gt;bin/&lt;/i&gt; sub folder, then it is also not required to specify a process.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The fact that the configuration system provides reasonable defaults, means that for trivial services we do not have to specify any configuration properties at all -- simply providing a single executable in the package's &lt;i&gt;bin/&lt;/i&gt; sub folder suffices.&lt;br /&gt;&lt;br /&gt;Do these simple configuration facilities really suffice to manage all kinds of system services? The answer is most likely no, because we may also want to manage processes that cannot daemonize on their own, or we may need to initialize some state first before the service can be used.&lt;br /&gt;&lt;br /&gt;To provide these additional facilities, we can create a &lt;b&gt;wrapper&lt;/b&gt; script around the executable and refer to it in the &lt;i&gt;process&lt;/i&gt; field of the deployment specification.&lt;br /&gt;&lt;br /&gt;The following Nix expression generates a deployment configuration for a service that requires state and only runs as a foreground process:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{stdenv, writeTextFile, writeScript, daemon, myForegroundService}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  myForegroundServiceWrapper = writeScript {&lt;br /&gt;    name = &quot;myforegroundservice-wrapper&quot;;&lt;br /&gt;    text = ''&lt;br /&gt;      #! ${stdenv.shell} -e&lt;br /&gt;&lt;br /&gt;      mkdir -p /var/lib/myservice&lt;br /&gt;      exec ${daemon}/bin/daemon -U -F /var/run/mydaemon.pid -- \&lt;br /&gt;        ${myForegroundService}/bin/myservice&lt;br /&gt;    '';&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;writeTextFile {&lt;br /&gt;  name = &quot;mydaemon&quot;;&lt;br /&gt;  text = ''&lt;br /&gt;    process=${myForegroundServiceWrapper}&lt;br /&gt;    pidFile=/var/run/mydaemon.pid&lt;br /&gt;  '';&lt;br /&gt;  destination = &quot;/etc/dysnomia/process&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As you may observe by looking at the Nix expression shown above, the Nix expression generates a wrapper script that does the following:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;First, it creates the required state directory: &lt;i&gt;/var/lib/myservice&lt;/i&gt; so that the service can work properly.&lt;/li&gt;&lt;li&gt;Then it invokes libslack's &lt;a href=&quot;http://www.libslack.org/daemon&quot;&gt;&lt;i&gt;daemon&lt;/i&gt;&lt;/a&gt; command to automatically daemonize the service. The &lt;i&gt;daemon&lt;/i&gt; command will automatically store a PID file containing the daemon's process ID, so that the configuration system knows how to terminate it. The value of the &lt;i&gt;-F&lt;/i&gt; parameter passed to the &lt;i&gt;daemon&lt;/i&gt; executable and the &lt;i&gt;pidFile&lt;/i&gt; configuration property are the same.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Typically, in deployment systems that use a data-driven configuration language (such as YAML or JSON) obtaining a wrapped executable is a burden, but in the Nix expression language this is quite convenient -- the language allows you to automatically build packages and other static artifacts such as configuration files and scripts, and pass their corresponding Nix store paths as parameters to configuration files.&lt;br /&gt;&lt;br /&gt;The combination of wrapper scripts and a simple configuration file suffices to manage all kinds of services, but it is fairly low-level -- to automate the deployment process of a system service, you basically need to re-implement the same kinds of configuration properties all over again.&lt;br /&gt;&lt;br /&gt;In the Nix process mangement-framework, I have developed a &lt;strong&gt;high-level&lt;/strong&gt; abstraction function for creating managed processes that can be used to target all kinds of process managers:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createManagedProcess, runtimeDir}:&lt;br /&gt;{port}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = import ../../webapp;&lt;br /&gt;in&lt;br /&gt;createManagedProcess rec {&lt;br /&gt;  name = &quot;webapp&quot;;&lt;br /&gt;  description = &quot;Simple web application&quot;;&lt;br /&gt;&lt;br /&gt;  # This expression can both run in foreground or daemon mode.&lt;br /&gt;  # The process manager can pick which mode it prefers.&lt;br /&gt;  process = &quot;${webapp}/bin/webapp&quot;;&lt;br /&gt;  daemonArgs = [ &quot;-D&quot; ];&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;    PID_FILE = &quot;${runtimeDir}/${name}.pid&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is a constructor function that generates a configuration for a web application process (with an embedded HTTP server) that returns a static HTML page.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;createManagedProcess&lt;/i&gt; function abstraction function can be used to generate configuration artifacts for systemd, supervisord, and launchd and various kinds of scripts, such as sysvinit scripts and BSD rc scripts.&lt;br /&gt;&lt;br /&gt;I can also easily adjust the generator infrastructure to generate the configuration files shown earlier (capturing the path of an executable and a PID file) with a wrapper script.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Managing daemons with Disnix&lt;/h2&gt;&lt;br /&gt;As explained in earlier blog posts about Disnix, services in a Disnix deployment model are abstract representations of basically any kind of deployment unit.&lt;br /&gt;&lt;br /&gt;Every service is annotated with a &lt;i&gt;type&lt;/i&gt; field. Disnix consults &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/03/deployment-of-mutable-components.html&quot;&gt;a plugin system named Dysnomia&lt;/a&gt; to invoke the corresponding plugin that can manage the lifecycle of that service, e.g. by activating or deactivating it.&lt;br /&gt;&lt;br /&gt;Implementing a Dysnomia module for directly managing daemons is quite straight forward -- as an activation step I just have to start the process defined in the configuration file (or the single executable that resides in the &lt;i&gt;bin/&lt;/i&gt; sub folder of the package).&lt;br /&gt;&lt;br /&gt;As a deactivation step (which purpose is to stop a process) I simply need to send a &lt;i&gt;TERM&lt;/i&gt; signal to the PID in the PID file, by running:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ kill $(cat $pidFile)&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Translation to a Disnix deployment specification&lt;/h2&gt;&lt;br /&gt;The last remaining bits in the puzzle is process dependency management and the translation to a Disnix services model so that Disnix can carry out the deployment.&lt;br /&gt;&lt;br /&gt;Deployments managed by the Nix process management framework are driven by so-called &lt;b&gt;processes models&lt;/b&gt; that capture the properties of running process instances, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{ pkgs ? import  { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;disnix&quot;&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxyHostBased {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is a simple example of a processes model defining two running processes:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;i&gt;webapp&lt;/i&gt; process is the web application process described earlier that runs an embedded HTTP server and serves a static HTML page.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;nginxReverseProxy&lt;/i&gt; is an Nginx web server that acts as a reverse proxy server for the &lt;i&gt;webapp&lt;/i&gt; process. To make this service to work properly, it needs to be activated after the &lt;i&gt;webapp&lt;/i&gt; process is activated. To ensure that the activation is done in the right order, &lt;i&gt;webapp&lt;/i&gt; is passed as a process dependency to the &lt;i&gt;nginxReverseProxyHostBased&lt;/i&gt; constructor function.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;As explained in previous blog posts, Disnix deployments are driven by three kinds of deployment specifications: a &lt;b&gt;services&lt;/b&gt; model that captures the service components of which a system consists, an &lt;b&gt;infrastructure&lt;/b&gt; model that captures all available target machines and their configuration properties and a &lt;b&gt;distribution&lt;/b&gt; model that maps services in the services model to machines in the infrastructure model.&lt;br /&gt;&lt;br /&gt;The processes model and Disnix services model are quite similar -- the latter is actually a superset of the processes model.&lt;br /&gt;&lt;br /&gt;We can translate process instances to Disnix services in a straight forward manner. For example, the &lt;i&gt;nginxReverseProxy&lt;/i&gt; process can be translated into the following Disnix service configuration:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;nginxReverseProxy = rec {&lt;br /&gt;  name = &quot;nginxReverseProxy&quot;;&lt;br /&gt;  port = 8080;&lt;br /&gt;&lt;br /&gt;  pkg = constructors.nginxReverseProxyHostBased {&lt;br /&gt;    webapps = [ webapp ];&lt;br /&gt;    inherit port;&lt;br /&gt;  } {};&lt;br /&gt;&lt;br /&gt;  activatesAfter = {&lt;br /&gt;    inherit webapp;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  type = &quot;process&quot;;&lt;br /&gt;};&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above specification, the process configuration has been augmented with the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;A &lt;i&gt;name&lt;/i&gt; property because this is a mandatory field for every service.&lt;/li&gt;&lt;li&gt;In the process management framework all process instances are managed by the same process manager, but in Disnix services can have all kinds of shapes and formes and require a plugin to manage their life-cycles.&lt;br /&gt;&lt;br /&gt;To allow Disnix to manage daemons, we specify the &lt;i&gt;type&lt;/i&gt; property to refer to our &lt;i&gt;process&lt;/i&gt; Dysnomia module that starts and terminates a daemon from a simple textual specification.&lt;/li&gt;&lt;li&gt;The process dependencies are translated to Disnix inter-dependencies by using the &lt;i&gt;activatesAfter&lt;/i&gt; property.&lt;br /&gt;&lt;br /&gt;In Disnix, inter-dependency parameters serve two purposes -- they provide the inter-dependent services with configuration parameters and they ensure the correct activation ordering.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;activatesAfter&lt;/i&gt; parameter disregards the first inter-dependency property, because we are already using the process management framework's convention for propagating process dependencies.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To allow Disnix to carry out the deployment of processes only a services model does not suffice. Since we are only interested in local deployment, we can just provide an infrastructure model with only a localhost target and a distribution model that maps all services to localhost.&lt;br /&gt;&lt;br /&gt;To accomplish this, we can use the same principles for local deployments described in the previous blog post.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;An example deployment scenario&lt;/h2&gt;&lt;br /&gt;I have added a new tool called &lt;i&gt;nixproc-disnix-switch&lt;/i&gt; to the Nix process management framework that automatically converts processes models into Disnix deployment models and invokes Disnix to locally deploy a system.&lt;br /&gt;&lt;br /&gt;The following command will carry out the complete deployment of our webapp example system, shown earlier, using Disnix as a simple dependency-based process manager:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nixproc-disnix-switch --state-dir /home/sander/var \&lt;br /&gt;  --force-disable-user-change processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In addition to using Disnix for deploying processes, we can also use its other features. For example, another application of Disnix I typically find useful is the deployment visualization tool.&lt;br /&gt;&lt;br /&gt;We can also use Disnix to generate a &lt;a href=&quot;https://graphviz.org&quot;&gt;DOT graph&lt;/a&gt; from the deployment architecture of the currently deployed system and generate an image from it:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-visualize &amp;gt; out.dot&lt;br /&gt;$ dot -Tpng out.dot &amp;gt; out.png&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Resulting in the following diagram:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-y3CYMKaDby4/XuFHrkwirKI/AAAAAAAAKHM/pJIIhZeJcsgZUX9_12l3ADjsFKWGY2dvACLcBGAsYHQ/s1600/deploymentarch.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://3.bp.blogspot.com/-y3CYMKaDby4/XuFHrkwirKI/AAAAAAAAKHM/pJIIhZeJcsgZUX9_12l3ADjsFKWGY2dvACLcBGAsYHQ/s1600/deploymentarch.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;In the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;first blog post&lt;/a&gt; that I wrote about the Nix process management framework (in which I explored a functional discipline using sysvinit-scripts as a basis), I was using hand-drawn diagrams to illustrate deployments.&lt;br /&gt;&lt;br /&gt;With the Disnix backend, I can use Disnix's visualization tool to automatically generate these diagrams.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Discussion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have shown that by implementing a few very simple concepts, we can use Disnix as a process management backend for the experimental Nix-based process management framework.&lt;br /&gt;&lt;br /&gt;Although it was fun to develop a simple process management solution, my goal is not to compete with existing process management solutions (such as systemd, launchd or supervisord) -- this solution is primarily designed for simple use cases and local experimentation.&lt;br /&gt;&lt;br /&gt;For production deployments, you probably still want to use a more sophisticated solution. For example, in production scenarios you also want to check the status of running processes and send them reload instructions. These are features that the Disnix backend does not support.&lt;br /&gt;&lt;br /&gt;The Nix process management framework supports a variety of process managers, but none of them can be universally used on all platforms that Disnix can run on. For example, the &lt;i&gt;sysvinit-script&lt;/i&gt; module works conveniently for local deployments but is restricted to Linux only. Likewise the &lt;i&gt;bsdrc-script&lt;/i&gt; module only works on FreeBSD (and theoretically on NetBSD and OpenBSD). &lt;i&gt;supervisord&lt;/i&gt; works on most UNIX-like systems, but is not self contained -- processes rely on the availablity of the supervisord service to run.&lt;br /&gt;&lt;br /&gt;This Disnix-based process management solution is simple and portable to all UNIX-like systems that Disnix has been tested on.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;process&lt;/i&gt; module described in this blog post is a replacement for the &lt;i&gt;process&lt;/i&gt; module that already exists in the current release of Dysnomia. The reason why I want it to be replaced is that Dysnomia now provides better alternatives to the old process module.&lt;br /&gt;&lt;br /&gt;For example, when it is desired to have your process managed by systemd, then the new &lt;i&gt;systemd-unit&lt;/i&gt; module should be used that is more reliable, supports many more features and has a simpler implementation.&lt;br /&gt;&lt;br /&gt;Furthermore, I made a couple of mistakes in the past. The old process module was originally implemented as a simple module that would start a foreground process in the background, by using the &lt;a href=&quot;https://linux.die.net/man/1/nohup&quot;&gt;&lt;i&gt;nohup&lt;/i&gt;&lt;/a&gt; command. At the time I developed that module, I did not know much about developing daemons, nor about the additional steps daemons need to carry out to make themselves well-behaving.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;nohup&lt;/i&gt; is not a proper solution for daemonizing foreground processes, such as critical system services -- a process might inherit privacy-sensitive environment variables, does not change the current working directory to the root folder and keep external drives mounted, and could also behave unpredictably if signal handlers have been changed from the default behaviour.&lt;br /&gt;&lt;br /&gt;At some point I believed that it is more reliable to use a process manager to manage the lifecycle of a process and adjusted the process module to do that. Originally I used Upstart for this purpose, and later I switched to systemd, with sysvinit-scripts (and the direct appraoch with &lt;i&gt;nohup&lt;/i&gt; as alternative implemenations).&lt;br /&gt;&lt;br /&gt;Basically the &lt;i&gt;process&lt;/i&gt; module provided three kinds of implementations in which none of them provided an optimal deployment experience.&lt;br /&gt;&lt;br /&gt;I made a similar mistake with Dysnomia's &lt;i&gt;wrapper&lt;/i&gt; module. Originally, its only purpose was to delegate the execution of deployment activities to a wrapper script included with the component that needs to be deployed. Because I was using this script mostly to deploy daemons, I have also adjusted the &lt;i&gt;wrapper&lt;/i&gt; module to use an external process manager to manage the lifecycle of the daemon that the &lt;i&gt;wrapper&lt;/i&gt; script might spawn.&lt;br /&gt;&lt;br /&gt;Because of these mistakes and poor separation of functionality, I have decided to deprecate the old &lt;i&gt;process&lt;/i&gt; and &lt;i&gt;wrapper&lt;/i&gt; modules. Since they are frequently used and I do not want to break compatibility with old deployments, they can still be used if Dysnomia is configured in legacy mode, which is the default setting for the time being.&lt;br /&gt;&lt;br /&gt;When using the old modules, Dysnomia will display a warning message explaining you that you should migrate to better alternatives.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The process &lt;a href=&quot;https://github.com/svanderburg/dysnomia&quot;&gt;Dysnomia&lt;/a&gt; module described in this blog post is part of the current development version of Dysnomia and will become available in the next release.&lt;br /&gt;&lt;br /&gt;The &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;Nix process management framework&lt;/a&gt; (which is still a highly-experimental prototype) includes the &lt;i&gt;disnix&lt;/i&gt; backend (described in this blog post), allowing you to automatically translate a processes model to Disnix deployment models and uses Disnix to deploy a system.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 11 Jun 2020 18:15:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Sander van der Burg: Deploying heterogeneous service-oriented systems locally with Disnix</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-3034296172802127376</guid>
	<link>http://sandervanderburg.blogspot.com/2020/05/deploying-heterogeneous-service.html</link>
	<description>In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/04/deploying-container-and-application.html&quot;&gt;the previous blog post&lt;/a&gt;, I have shown a new useful application area that is built on top of the combination of &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html&quot;&gt;my experimental Nix-based process management framework&lt;/a&gt; and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Both of these underlying solutions have a number of similarities -- as their names obviously suggest, they both strongly depend on &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;the Nix package manager&lt;/a&gt; to deploy all their package dependencies and static configuration artifacts, such as configuration files.&lt;br /&gt;&lt;br /&gt;Furthermore, they are both driven by models written in the &lt;b&gt;Nix expression language&lt;/b&gt; to automate the deployment processes of entire systems.&lt;br /&gt;&lt;br /&gt;These models are built on a number of simple conventions that are frequently used in the &lt;a href=&quot;https://nixos.org/nixpkgs&quot;&gt;Nix packages repository&lt;/a&gt;:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;All units of which a system consists are defined as Nix expressions declaring a &lt;b&gt;function&lt;/b&gt;. Each function parameter refers to a dependency or configuration property required to construct the unit from its sources.&lt;/li&gt;&lt;li&gt;To compose a particular variant of a unit, we must &lt;b&gt;invoke&lt;/b&gt; the function that builds and configures the unit with parameters providing the dependencies and configuration properties that the unit needs.&lt;/li&gt;&lt;li&gt;To make all units conveniently &lt;b&gt;accessible&lt;/b&gt; from a &lt;b&gt;single location&lt;/b&gt;, the content of the configuration units is typically blended into a symlink tree called &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/09/managing-user-environments-with-nix.html&quot;&gt;Nix profiles&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Besides these commonalities, their main difference is that the process management framework is specifically designed as a solution for systems that are composed out of &lt;b&gt;running processes&lt;/b&gt; (i.e. &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/01/writing-well-behaving-daemon-in-c.html&quot;&gt;daemons&lt;/a&gt; in UNIX terminology).&lt;br /&gt;&lt;br /&gt;This framework makes it possible to construct multiple instances of running processes, isolate their resources (by avoiding conflicting resource configuration properties), and manage running process with a variety of process management solutions, such as sysvinit scripts, BSD rc scripts, systemd, launchd and supervisord.&lt;br /&gt;&lt;br /&gt;The process management framework is quite useful for single machine deployments and local experimentation, but it does not do any &lt;b&gt;distributed&lt;/b&gt; deployment and &lt;b&gt;heterogeneous service deployment&lt;/b&gt; -- it cannot (at least not conveniently) deploy units that are not daemons, such as databases, Java web applications deployed to a Servlet container, PHP applications deployed to a PHP-enabled web server etc.&lt;br /&gt;&lt;br /&gt;Disnix is a solution to automate the deployment processes of service-oriented systems -- distributed systems that are composed of components, using a variety of technologies, into a network of machines.&lt;br /&gt;&lt;br /&gt;To accomplish full automation, Disnix integrates and combines a number of activities and tools, such as Nix for package management and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/deploying-state-with-disnix.html&quot;&gt;Dysnomia for state management&lt;/a&gt; (Dysnomia takes care of the activation, deactivation steps for services, and can optionally manage snapshots and restores of state). Dysnomia provides a plugin system that makes it possible to manage a variety of component types, including processes and databases.&lt;br /&gt;&lt;br /&gt;Disnix and Dysnomia can also include the features of the Nix process management framework for the deployment of services that are running processes, if desired.&lt;br /&gt;&lt;br /&gt;The scope of Disnix is quite broad in comparison to the process management framework, but it can also be used to automate all kinds of &lt;b&gt;sub problems&lt;/b&gt;. For example, it can also be used as &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/using-disnix-as-remote-package-deployer.html&quot;&gt;a remote package deployment solution&lt;/a&gt; to build and deploy packages in a network of heterogeneous machines (e.g. Linux and macOS).&lt;br /&gt;&lt;br /&gt;After comparing the properties of both deployment solutions, I have identified another interesting sub use case for Disnix -- deploying heterogeneous service-oriented systems (that are composed out of components using a variety of technologies) locally for experimentation purposes.&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe how Disnix can be used for local deployments.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Motivating example: deploying a Java-based web application and web service system&lt;/h2&gt;&lt;br /&gt;One of the examples I have shown in the previous blog post, is an over engineered Java-based web application and web service system which only purpose is to display the string: &quot;Hello world!&quot;.&lt;br /&gt;&lt;br /&gt;The &quot;Hello&quot; string is returned by the &lt;i&gt;HelloService&lt;/i&gt; and consumed by another service called &lt;i&gt;HelloWorldService&lt;/i&gt; that composes the sentence &quot;Hello world!&quot; from the first message. The &lt;i&gt;HelloWorld&lt;/i&gt; web application is the front-end responsible for displaying the sentence to the end user.&lt;br /&gt;&lt;br /&gt;When deploying the system to a single target machine, it could have the following deployment architecture:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-SoTrSg5o6xo/Xs1xv4DbQ_I/AAAAAAAAKFc/7gxV3KcSsaMgS1ss-_gA7UANHXrG6g8XwCLcBGAsYHQ/s1600/deploymentarch-local.png&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://3.bp.blogspot.com/-SoTrSg5o6xo/Xs1xv4DbQ_I/AAAAAAAAKFc/7gxV3KcSsaMgS1ss-_gA7UANHXrG6g8XwCLcBGAsYHQ/s640/deploymentarch-local.png&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;br /&gt;In the architecture diagram shown above, ovals denote services, arrows inter-dependency relationships (requiring that a service gets activated before another), the dark grey colored boxes container environments, and the light grey colored box a machine (which is only one machine in the above example).&lt;br /&gt;&lt;br /&gt;As you may notice, only one service in the diagram shown above is a daemon, namely Apache Tomcat (&lt;i&gt;simpleAppservingTomcat&lt;/i&gt;) that can be managed by the experimental Nix process management framework.&lt;br /&gt;&lt;br /&gt;The remainder of the services have a different kind of form -- the web application front-end (&lt;i&gt;HelloWorld&lt;/i&gt;) is a Java web application that is embedded in Catalina, the Servlet container that comes with Apache Tomcat. The web services are Axis2 archives that are deployed to the Axis2 container (that in turn is a web application managed by Apache Tomcat).&lt;br /&gt;&lt;br /&gt;In the previous blog post, I have shown that we can deploy and distribute these services over a small network of machines.&lt;br /&gt;&lt;br /&gt;It is also possible to completely deploy this system locally, without any external physical or virtual machines, and network connectivity.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Configuring the client interface for local deployment&lt;/h2&gt;&lt;br /&gt;To execute deployment tasks remotely, Disnix invokes an external process that is called a &lt;b&gt;client interface&lt;/b&gt;. By default, Disnix uses the &lt;i&gt;disnix-ssh-client&lt;/i&gt; that remotely executes commands via SSH and transfers data via SCP.&lt;br /&gt;&lt;br /&gt;It is also possible to use alternative client interfaces so that different communication protocols and methods can be used. For example, there is also an external package that provides a SOAP client &lt;i&gt;disnix-soap-client&lt;/i&gt; and a NixOps client (&lt;i&gt;disnix-nixops-client&lt;/i&gt;).&lt;br /&gt;&lt;br /&gt;Communication with a local Disnix service instance can also be done with a client interface. For example, configuring the following environment variable:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ export DISNIX_CLIENT_INTERFACE=disnix-client&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;instructs the Disnix tools to use the &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/dbus/&quot;&gt;D-Bus&lt;/a&gt; client to communicate with a local Disnix service instance.&lt;br /&gt;&lt;br /&gt;It is also possible to bypass the local Disnix service and directly execute all deployment activities with the following interface:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ export DISNIX_CLIENT_INTERFACE=disnix-runactivity&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The &lt;i&gt;disnix-runactivity&lt;/i&gt; client interface is particularly useful for single-user/unprivileged user deployments. In the former case, you need a Disnix D-Bus daemon running in the background that authorizes the user to execute deployments. For the latter, nothing is required beyond a single user Nix installation.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Deploying the example system locally&lt;/h2&gt;&lt;br /&gt;As explained in earlier blog posts about Disnix, deployments are driven by three kinds of deployment specifications: a &lt;b&gt;services&lt;/b&gt; model capturing all the services of which a system consists and how they depend on each other, an &lt;b&gt;infrastructure&lt;/b&gt; model captures all available target machines and their relevant configuration properties (including so-called container services that can host application services) and the &lt;b&gt;distribution&lt;/b&gt; model maps services in the services model to target machines in the infrastructure model (and container services that a machine may provide).&lt;br /&gt;&lt;br /&gt;Normally, Disnix deploys services to remote machines defined in the infrastructure model. For local deployments, we simply need to provide an infrastructure model with only one entry:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{&lt;br /&gt;  localhost.properties.hostname = &quot;localhost&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the distribution model, we must map all services to the &lt;i&gt;localhost&lt;/i&gt; target:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  simpleAppservingTomcat = [ infrastructure.localhost ];&lt;br /&gt;  axis2 = [ infrastructure.localhost ];&lt;br /&gt;&lt;br /&gt;  HelloService = [ infrastructure.localhost ];&lt;br /&gt;  HelloWorldService = [ infrastructure.localhost ];&lt;br /&gt;  HelloWorld = [ infrastructure.localhost ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;With the above infrastructure and distribution model that facilitates local deployment, and the services model of the example system shown above, we can deploy the entire system on our local machine:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;$ disnix-env -s services.nix -i infrastructure-local.nix -d distribution-local.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Deploying the example system locally as an unprivileged user&lt;/h2&gt;&lt;br /&gt;The deployment scenario shown earlier supports local deployment, but still requires super-user privileges. For example, to deploy Apache Tomcat, we must have write access to the state directory: &lt;i&gt;/var&lt;/i&gt; to configure Apache Tomcat's state and deploy the Java web application archives. An unprivileged user typically lacks the permissions to perform modifications in the &lt;i&gt;/var&lt;/i&gt; directory.&lt;br /&gt;&lt;br /&gt;One of they key features of the Nix process management framework is that it makes all state directories are configurable. State directories can be changed in such a way that also unprivileged users can deploy services (e.g. by changing the state directory to a sub folder in the user's home directory).&lt;br /&gt;&lt;br /&gt;Disnix service models can also define these process management configuration parameters:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{ pkgs, system, distribution, invDistribution&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;systemd&quot;&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  processType =&lt;br /&gt;    if processManager == null then &quot;managed-process&quot;&lt;br /&gt;    else if processManager == &quot;sysvinit&quot; then &quot;sysvinit-script&quot;&lt;br /&gt;    else if processManager == &quot;systemd&quot; then &quot;systemd-unit&quot;&lt;br /&gt;    else if processManager == &quot;supervisord&quot; then &quot;supervisord-program&quot;&lt;br /&gt;    else if processManager == &quot;bsdrc&quot; then &quot;bsdrc-script&quot;&lt;br /&gt;    else if processManager == &quot;cygrunsrv&quot; then &quot;cygrunsrv-service&quot;&lt;br /&gt;    else if processManager == &quot;launchd&quot; then &quot;launchd-daemon&quot;&lt;br /&gt;    else throw &quot;Unknown process manager: ${processManager}&quot;;&lt;br /&gt;&lt;br /&gt;  constructors = import ../../../nix-processmgmt/examples/service-containers-agnostic/constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir cacheDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  customPkgs = import ../top-level/all-packages.nix {&lt;br /&gt;    inherit system pkgs stateDir;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  simpleAppservingTomcat = constructors.simpleAppservingTomcat {&lt;br /&gt;    httpPort = 8080;&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression shows a partial Nix services model for the Java example system. The first four function parameters: &lt;i&gt;pkgs&lt;/i&gt;, &lt;i&gt;system&lt;/i&gt;, &lt;i&gt;distribution&lt;/i&gt;, and &lt;i&gt;invDistribution&lt;/i&gt; are standard Disnix service model parameters.&lt;br /&gt;&lt;br /&gt;The remainder of the parameters are specific to the process management framework -- they allow you to change the state directories, force disable user changing (this is useful for unprivileged user deployments) and the process manager it should use for daemons.&lt;br /&gt;&lt;br /&gt;I have added a new command-line parameter (&lt;i&gt;--extra-params&lt;/i&gt;) to the Disnix tools that can be used to propagate values for these additional parameters.&lt;br /&gt;&lt;br /&gt;With the following command-line instruction, we change the base directory of the state directories to the user's home directory, force disable user changing (only a privileged user can do this), and change the process manager to sysvinit scripts:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;$ disnix-env -s services.nix -i infrastructure-local.nix -d distribution-local.nix \&lt;br /&gt;  --extra-params '{&lt;br /&gt;  stateDir = &quot;/home/sander/var&quot;;&lt;br /&gt;  processManager = &quot;sysvinit&quot;;&lt;br /&gt;  forceDisableUserChange = true;&lt;br /&gt;}'&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;With the above command, we can deploy the example system completely as an unprivileged user, without requiring any process/service manager to manage Apache Tomcat.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Working with predeployed container services&lt;/h2&gt;&lt;br /&gt;In our examples so far, we have deployed systems that are entirely self contained. However, it is also possible to deploy services to container services that have already been deployed by other means. For example, it is also possible to install Apache Tomcat with your host system's distribution and use Dysnomia to integrate with that.&lt;br /&gt;&lt;br /&gt;To allow Disnix to deploy services to these containers, we need an infrastructure model that knows its properties. We can automatically generate an infrastructure model from the Dysnomia container configuration files, by running:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-capture-infra infrastructure.nix &amp;gt; \&lt;br /&gt;  infrastructure-captured.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and using the captured infrastructure model to locally deploy the system:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;$ disnix-env -s services.nix -i infrastructure-captured.nix -d distribution-local.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Undeploying a system&lt;/h2&gt;&lt;br /&gt;For local experimentation, it is probably quite common that you want to completely undeploy the system as soon as you no longer need it. Normally, this should be done by writing an empty distribution model and redeploying the system with that empty distribution model, but that is still a bit of a hassle.&lt;br /&gt;&lt;br /&gt;In the latest development version of Disnix, an undeploy can be done with the following command-line instruction:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-env --undeploy -i infrastructure.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;--extra-params&lt;/i&gt; and &lt;i&gt;--undeploy&lt;/i&gt; Disnix command-line options are part of the current development version of Disnix and will become available in the next release.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Tue, 26 May 2020 21:49:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Tweag I/O: Nix Flakes, Part 1: An introduction and tutorial</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-05-25-flakes/</guid>
	<link>https://tweag.io/blog/2020-05-25-flakes/</link>
	<description>An introduction to Nix flakes and a tutorial on how to use them.</description>
	<pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Deploying container and application services with Disnix</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-7320527361984147016</guid>
	<link>http://sandervanderburg.blogspot.com/2020/04/deploying-container-and-application.html</link>
	<description>As described in many previous blog posts, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt;'s purpose is to deploy &lt;b&gt;service-oriented systems&lt;/b&gt; -- systems that can be decomposed into inter-connected service components, such as databases, web services, web applications and processes -- to networks of machines.&lt;br /&gt;&lt;br /&gt;To use Disnix effectively, two requirements must be met:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;A system must be &lt;b&gt;decomposed&lt;/b&gt; into independently deployable services, and these services must be packaged with &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;Nix&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Services may require other services that provide environments with essential facilities to run them. In Disnix terminology, these environments are called &lt;b&gt;containers&lt;/b&gt;. For example, to host a MySQL database, Disnix requires a MySQL DBMS as a container, to run a Java web application archive you need a Java Servlet container, such as Apache Tomcat, and to run a &lt;a href=&quot;https://en.wikipedia.org/wiki/Daemon_(computing)&quot;&gt;daemon&lt;/a&gt; it needs a process manager, such as &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd/&quot;&gt;systemd&lt;/a&gt;, &lt;a href=&quot;https://www.launchd.info/&quot;&gt;launchd&lt;/a&gt; or &lt;a href=&quot;http://supervisord.org/&quot;&gt;supervisord&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Disnix was originally designed to only deploy the (functional) application components (called &lt;strong&gt;services&lt;/strong&gt; in Disnix terminology) of which a service-oriented systems consists, but it was not designed to handle the deployment of any underlying container services.&lt;br /&gt;&lt;br /&gt;In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/05/a-reference-architecture-for.html&quot;&gt;my PhD thesis&lt;/a&gt;, I called Disnix's problem domain &lt;b&gt;service deployment&lt;/b&gt;. Another problem domain that I identified was &lt;b&gt;infrastructure deployment&lt;/b&gt; that concerns the deployment of machine configurations, including container services.&lt;br /&gt;&lt;br /&gt;The fact that these problem domains are separated means that, if we want to fully deploy a service-oriented system from scratch, we basically need to do infrastructure deployment first, e.g. install a collection of machines with system software and these container services, such as MySQL and Apache Tomcat, and once that is done, we can use these machines as deployment targets for Disnix.&lt;br /&gt;&lt;br /&gt;There are a variety of solutions available to automate infrastructure deployment. Most notably, &lt;a href=&quot;http://github.com/nixos/nixops&quot;&gt;NixOps&lt;/a&gt; can be used to automatically deploy networks of &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nixos-purely-functional-linux.html&quot;&gt;NixOS&lt;/a&gt; configurations, and (if desired) automatically instantiate virtual machines in a cloud/&lt;a href=&quot;https://en.wikipedia.org/wiki/Infrastructure_as_a_service&quot;&gt;IaaS&lt;/a&gt; environment, such as &lt;a href=&quot;https://aws.amazon.com/ec2/&quot;&gt;Amazon EC2&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Although &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/03/on-nixops-disnix-service-deployment-and.html&quot;&gt;combining NixOps for infrastructure deployment with Disnix for service deployment&lt;/a&gt; works great in many scenarios, there are still a number of concerns that are not adequately addressed:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Infrastructure and service deployment are still two (somewhat) &lt;b&gt;separated processes&lt;/b&gt;. Although I have developed an extension toolset (called DisnixOS) to combine Disnix with the deployment concepts of NixOS and NixOps, we still need to run two kinds of deployment procedures. Ideally, it would be nice to fully automate the entire deployment process with only one command.&lt;/li&gt;&lt;li&gt;Although NixOS (and NixOps that extends NixOS' concepts to networks of machines and the cloud) do a great job in fully automating the deployments of machines, we can only reap their benefits if we can permit ourselves use to NixOS, which is a particular &lt;b&gt;Linux distribution&lt;/b&gt; flavour -- sometimes you may need to deploy services to conventional Linux distributions, or different kinds of operating systems (after all, one of the reasons to use service-oriented systems is to be able to use a diverse set of technologies).&lt;br /&gt;&lt;br /&gt;The Nix package manager also works on other operating systems than Linux, such macOS, but there is no Nix-based deployment automation solution that can universally deploy infrastructure components to other operating systems (the only other infrastructure deployment solution that provides similar functionality to NixOS is the the &lt;a href=&quot;https://github.com/LnL7/nix-darwin&quot;&gt;nix-darwin&lt;/a&gt; repository, that can only be used on macOS).&lt;/li&gt;&lt;li&gt;The NixOS module system does &lt;b&gt;not&lt;/b&gt; facilitate the deployment of &lt;b&gt;multiple instances&lt;/b&gt; of infrastructure components. Although this is probably a very uncommon use case, it is also possible to run two MySQL DBMS services on one machine and use both of them as Disnix deployment targets for databases.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In a Disnix-context, services have no specific meaning or shape and can basically represent anything -- a satellite tool providing a plugin system (called &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/deploying-state-with-disnix.html&quot;&gt;Dysnomia&lt;/a&gt;) takes care of most of their deployment steps, such as their activation and deactivation.&lt;br /&gt;&lt;br /&gt;A couple of years ago, I have demonstrated with a proof of concept implementation that &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;we can use Disnix and Dysnomia's features to deploy infrastructure components&lt;/a&gt;. This deployment approach is also capable of deploying multiple instances of container services to one machine.&lt;br /&gt;&lt;br /&gt;Recently, I have revisited that idea again and extended it so that we can now deploy a service-oriented system including most underlying container services with a single command-line instruction.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;About infrastructure deployment solutions&lt;/h2&gt;&lt;br /&gt;As described in the introduction, Disnix's purpose is service deployment and not infrastructure deployment. In the past, I have been using a variety of solutions to manage the underlying infrastructure of service-oriented systems:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;In the very beginning, while working on my master thesis internship (in which I built the first prototype version of Disnix), there was not much automation at all -- for most of my testing activities I &lt;b&gt;manually&lt;/b&gt; created VirtualBox virtual machines and manually installed NixOS on them, with all essential container servers, such as Apache Tomcat and MySQL, because these were the container services that my target system required.&lt;br /&gt;&lt;br /&gt;Even after some decent Nix-based automated solutions appeared, I still ended up doing manual deployments for non-NixOS machines. For example, I still remember &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/11/deploying-services-to-heterogeneous.html&quot;&gt;the steps I had to perform to prepare myself for the demo I gave at NixCon 2015&lt;/a&gt;, in which I configured a small heterogeneous network consisting of an Ubuntu, NixOS, and Windows machine. It took me many hours of preparation time to get the demo right.&lt;/li&gt;&lt;li&gt;Some time later, for a research paper about &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/using-nixos-for-declarative-deployment.html&quot;&gt;declarative deployment and testing&lt;/a&gt;, we have developed a tool called &lt;i&gt;nixos-deploy-network&lt;/i&gt; that deploys NixOS configurations in a network of machines and is driven by a networked NixOS configuration file.&lt;/li&gt;&lt;li&gt;Around the same time, I have also developed a similar tool called: &lt;i&gt;disnixos-deploy-network&lt;/i&gt; that uses Disnix's deployment mechanisms to remotely deploy a network of NixOS configurations. It was primarily developed to show that Disnix's plugin system: Dysnomia, could also treat entire NixOS configurations as services.&lt;/li&gt;&lt;li&gt;When NixOps appeared (initially it was called Charon), I have also created facilities in the DisnixOS toolset to integrate with it -- for example DisnixOS can automatically convert a NixOps configuration to a Disnix infrastructure model.&lt;/li&gt;&lt;li&gt;And finally, I have created a proof of concept implementation that shows that Disnix can also treat every container service as a Disnix service and deploy it.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The idea behind the last approach is that we deploy two systems in sequential order with Disnix -- the former consisting of the container services and the latter of the application services.&lt;br /&gt;&lt;br /&gt;For example, if we want to deploy a system that consists of a number of Java web applications and MySQL databases, such as the infamous &lt;a href=&quot;https://github.com/svanderburg/disnix-stafftracker-java-example&quot;&gt;Disnix StaffTracker example application (Java version)&lt;/a&gt;, then we must first deploy a system with Disnix that provides the containers: the MySQL DBMS and Apache Tomcat:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-env -s services-containers.nix \&lt;br /&gt;  -i infrastructure-bare.nix \&lt;br /&gt;  -d distribution-containers.nix \&lt;br /&gt;  --profile containers&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As described in earlier blog posts about Disnix, deployments are driven by three configuration files -- the &lt;b&gt;services&lt;/b&gt; model captures all distributable components of which the system consists (called services in a Disnix-context), the &lt;b&gt;infrastructure&lt;/b&gt; model captures all target machines in the network and their relevant properties, and the &lt;b&gt;distribution&lt;/b&gt; model specifies the mappings of services in the services model to the target machines (and container services already available on the machines in the network).&lt;br /&gt;&lt;br /&gt;All the container services in the services model provide above refer to systemd services, that in addition to running Apache Tomcat and MySQL, also do the following:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;They bundle a &lt;strong&gt;Dysnomia plugin&lt;/strong&gt; that can be used to manage the life-cycles of Java web applications and MySQL databases.&lt;/li&gt;&lt;li&gt;They bundle a &lt;strong&gt;Dysnomia container&lt;/strong&gt; configuration file capturing all relevant container configuration properties, such as the MySQL TCP port the daemon listens to, and the Tomcat web application deployment directory.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;For example, the Nix expression that configures Apache Tomcat has roughly the following structure:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;&lt;br /&gt;{stdenv, dysnomia, httpPort, catalinaBaseDir, instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;stdenv.mkDerivation {&lt;br /&gt;  name = &quot;simpleAppservingTomcat&quot;;&lt;br /&gt;  ...&lt;br /&gt;  postInstall = ''&lt;br /&gt;    # Add Dysnomia container configuration file for a Tomcat web application&lt;br /&gt;    mkdir -p $out/etc/dysnomia/containers&lt;br /&gt;    cat &amp;gt; $out/etc/dysnomia/containers/tomcat-webapplication${instanceSuffix} &amp;lt;&amp;lt;EOF&lt;br /&gt;    tomcatPort=${toString httpPort}&lt;br /&gt;    catalinaBaseDir=${catalinaBaseDir}&lt;br /&gt;    EOF&lt;br /&gt;&lt;br /&gt;    # Copy the Dysnomia module that manages an Apache Tomcat web application&lt;br /&gt;    mkdir -p $out/libexec/dysnomia&lt;br /&gt;    ln -s ${dysnomia}/libexec/dysnomia/tomcat-webapplication $out/libexec/dysnomia&lt;br /&gt;  '';&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;First, the Nix expression will build and configure Apache Tomcat (this is left out of the example to keep it short). After Apache Tomcat has been built and configured, the Nix expression generates the container configuration file and copies the &lt;i&gt;tomcat-webapplication&lt;/i&gt; Dysnomia module from the Dysnomia toolset.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;disnix-env&lt;/i&gt; command-line instruction shown earlier, deploys container services to target machines in the network, using a bare infrastructure model that does not provide any container services except the init system (which is systemd on NixOS). The &lt;i&gt;profile&lt;/i&gt; parameter specifies a Disnix &lt;strong&gt;profile&lt;/strong&gt; to tell the tool that we are deploying a different kind of system than the default.&lt;br /&gt;&lt;br /&gt;If the command above succeeds, then we have all required container services at our disposal. The deployment architecture of the resulting system may look as follows:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-s0BNMwOC1d0/XqdCcmJYJsI/AAAAAAAAKBY/Xyln6YE1Xqs-eOhpEImsE2TJZ7gmfT-8gCLcBGAsYHQ/s1600/deploymentarch-containers.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://4.bp.blogspot.com/-s0BNMwOC1d0/XqdCcmJYJsI/AAAAAAAAKBY/Xyln6YE1Xqs-eOhpEImsE2TJZ7gmfT-8gCLcBGAsYHQ/s640/deploymentarch-containers.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;In the above diagram, the light grey colored boxes correspond to machines in a network, the dark grey boxes to container environments, and white ovals to services.&lt;br /&gt;&lt;br /&gt;As you may observe, we have deployed three services -- to the &lt;i&gt;test1&lt;/i&gt; machine we have deployed an Apache Tomcat service (that itself is managed by systemd), and to the &lt;i&gt;test2&lt;/i&gt; machine we have deployed both Apache Tomcat and the MySQL server (both their lifecycles are managed with systemd).&lt;br /&gt;&lt;br /&gt;We can run the following command to generate a new infrastructure model that provides the properties of these newly deployed container services:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-capture-infra infrastructure-bare.nix &amp;gt; infrastructure.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As shown earlier, the retrieved infrastructure model provides all relevant configuration properties of the MySQL and Apache Tomcat containers that we have just deployed, because they expose their configuration properties via container configuration files.&lt;br /&gt;&lt;br /&gt;By using the retrieved infrastructure model and running the following command, we can deploy our web application and database components:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-env -s services.nix \&lt;br /&gt;  -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix \&lt;br /&gt;  --profile services&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above command-line invocation, the services model contains all application components, and the distribution model maps these application components to the corresponding target machines and their containers.&lt;br /&gt;&lt;br /&gt;As with the previous &lt;i&gt;disnix-env&lt;/i&gt; command invocation, we provide a &lt;i&gt;--profile&lt;/i&gt; parameter to tell Disnix that we are deploying a different system. If we would use the same profile parameter as in the previous example, then Disnix will undeploy the container services and tries to upgrade the system with the application services, which will obviously fail.&lt;br /&gt;&lt;br /&gt;If the above command succeeds, then we have successfully deployed both the container and application services that our example system requires, resulting in a fully functional and activated system with a deployment architecture that may have the following structure:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-8EJWISAWP1o/XqdG_AWLYuI/AAAAAAAAKBk/aZBsQYwsy-c9huv78D03D1RFfQ41KACqQCLcBGAsYHQ/s1600/deploymentarch-services.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; height=&quot;235&quot; src=&quot;https://3.bp.blogspot.com/-8EJWISAWP1o/XqdG_AWLYuI/AAAAAAAAKBk/aZBsQYwsy-c9huv78D03D1RFfQ41KACqQCLcBGAsYHQ/s640/deploymentarch-services.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As may you may observe by looking at the diagram above, we have deployed a system that consists of a number of MySQL databases, Java web services and Java web applications.&lt;br /&gt;&lt;br /&gt;The diagram uses the same notational conventions used in the previous diagram. The arrows denote inter-dependency relationships, telling Disnix that one service depends on another, and that dependency should be deployed first.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Exposing services as containers&lt;/h2&gt;&lt;br /&gt;The Disnix service container deployment approach that I just described works, but it is not an integrated solution -- it has a limitation that is comparable to the infrastructure and services deployment separation that I have explained earlier. It requires you to run two deployments: one for the containers and one for the services.&lt;br /&gt;&lt;br /&gt;In the blog post that I wrote a couple of years ago, I also explained that in order to fully automate the entire process with a single command, this might eventually lead to &quot;a layered deployment approach&quot; -- the idea was to combine several system deployment processes into one. For example, you might want to deploy a service manager in the first layer, the container services for application components in the second, and in the third the application components themselves.&lt;br /&gt;&lt;br /&gt;I also argued that it is probably not worth spending a lot of effort in automating multiple deployment layers -- for nearly all systems that I deployed there were only two &quot;layers&quot; that I need to keep track of -- the infrastructure layer providing container services, and a service layer providing the application services. NixOps sufficed as a solution to automate the infrastructure parts for most of my use cases, except for deployment to non-NixOS machines, and deploying multiple instances of container services, which is a very uncommon use case.&lt;br /&gt;&lt;br /&gt;However, I got inspired to revisit this problem again after I completed my work described in &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html&quot;&gt;the previous blog post&lt;/a&gt; -- in my previous blog post, I have created a process manager-agnostic service management framework that works with a variety of process managers on a variety of operating systems.&lt;br /&gt;&lt;br /&gt;Combining this framework with Disnix, makes it possible to also easily deploy container services (most of them are daemons) to non-NixOS machines, including non-Linux machines, such as macOS and FreeBSD from the same declarative specifications.&lt;br /&gt;&lt;br /&gt;Moreover, this framework also provides facilities to easily deploy multiple instances of the same service to the same machine.&lt;br /&gt;&lt;br /&gt;Revisiting this problem also made me think about the &quot;layered approach&quot; again, and after some thinking I have dropped the idea. The problem of using layers is that:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;We need to develop &lt;b&gt;another tool&lt;/b&gt; that integrates the deployment processes of all layers into one. In addition to the fact that we need to implement more automation, this introduces many additional technical challenges -- for example, if we want to deploy three layers and the deployment of the second fails, how are we going to do a rollback?&lt;/li&gt;&lt;li&gt;A layered approach is somewhat &quot;&lt;b&gt;imperative&lt;/b&gt;&quot; -- each layer deploys services that include Dysnomia modules and Dysnomia container configuration files. The Disnix service on each target machine performs a lookup in the Nix profile that contains all packages of the containers layer to find the required Dysnomia modules and container configuration files.&lt;br /&gt;&lt;br /&gt;Essentially, Dysnomia modules and container configurations are stored in a global namespace. This means the order in which the deployment of the layers is executed is important and that each layer can imperatively modify the behaviour of each Dysnomia module.&lt;/li&gt;&lt;li&gt;Because we need to deploy the system on layer-by-layer basis, we cannot for example, deploy multiple services in another layer that have no dependency in parallel, making a deployment process &lt;b&gt;slower&lt;/b&gt; than it should be.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;After some thinking, I came up with a much simpler approach -- I have introduced a new concept to the Disnix services model that makes it possible to &lt;b&gt;annotate&lt;/b&gt; services with a specification of the &lt;b&gt;container services&lt;/b&gt; that it provides. This information can be used by application services that need to deploy to this container service.&lt;br /&gt;&lt;br /&gt;For example, we can annotate the Apache Tomcat service in the Disnix services model as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{ pkgs, system, distribution, invDistribution&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;systemd&quot;&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ../../../nix-processmgmt/examples/services-agnostic/constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir cacheDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  simpleAppservingTomcat = rec {&lt;br /&gt;    name = &quot;simpleAppservingTomcat&quot;;&lt;br /&gt;    pkg = constructors.simpleAppservingTomcat {&lt;br /&gt;      inherit httpPort;&lt;br /&gt;      commonLibs = [ &quot;${pkgs.mysql_jdbc}/share/java/mysql-connector-java.jar&quot; ];&lt;br /&gt;    };&lt;br /&gt;    httpPort = 8080;&lt;br /&gt;    catalinaBaseDir = &quot;/var/tomcat/webapps&quot;;&lt;br /&gt;    type = &quot;systemd-unit&quot;;&lt;br /&gt;    providesContainers = {&lt;br /&gt;      tomcat-webapplication = {&lt;br /&gt;        httpPort = 8080;&lt;br /&gt;        catalinaBaseDir = &quot;/var/tomcat/webapps&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  GeolocationService = {&lt;br /&gt;    name = &quot;GeolocationService&quot;;&lt;br /&gt;    pkg = customPkgs.GeolocationService;&lt;br /&gt;    dependsOn = {};&lt;br /&gt;    type = &quot;tomcat-webapplication&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, the &lt;i&gt;simpleAppservingTomcat&lt;/i&gt; service refers to an Apache Tomcat server that serves Java web applications for one particular virtual host. The &lt;i&gt;providesContainers&lt;/i&gt; property tells Disnix that the service is a container provider, providing a container named: &lt;i&gt;tomcat-webapplication&lt;/i&gt; with the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;For HTTP traffic, Apache Tomcat should listen on TCP port 8080&lt;/li&gt;&lt;li&gt;The Java web application archives (WAR files) should be deployed to the Catalina Servlet container. By copying the WAR files to the &lt;i&gt;/var/tomcat/webapps&lt;/i&gt; directory, they should be automatically hot-deployed.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The other service in the services model (&lt;i&gt;GeolocationService&lt;/i&gt;) is a Java web application that should be deployed to a Apache Tomcat container service.&lt;br /&gt;&lt;br /&gt;If in a Disnix distribution model, we map the Apache Tomcat service (&lt;i&gt;simpleAppservingTomcat&lt;/i&gt;) and the Java web application (&lt;i&gt;GeolocationService&lt;/i&gt;) to the same machine:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  simpleAppservingTomcat = [ infrastructure.test1 ];&lt;br /&gt;  GeolocationService = [ infrastructure.test1 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Disnix will automatically search for a suitable container service provider for each service.&lt;br /&gt;&lt;br /&gt;In the above scenario, Disnix knows that &lt;i&gt;simpleAppservingTomcat&lt;/i&gt; provides a &lt;i&gt;tomcat-webapplication&lt;/i&gt; container. The &lt;i&gt;GeolocationService&lt;/i&gt; uses the type: &lt;i&gt;tomcat-webapplication&lt;/i&gt; indicating that it needs to deployed to a Apache Tomcat servlet container.&lt;br /&gt;&lt;br /&gt;Because these services have been deployed to the same machine Disnix will make sure that Apache Tomcat gets activated before the &lt;i&gt;GeolocationService&lt;/i&gt;, and uses the Dysnomia module that is bundled with the &lt;i&gt;simpleAppservingTomcat&lt;/i&gt; to handle the deployment of the Java web application.&lt;br /&gt;&lt;br /&gt;Furthermore, the properties that &lt;i&gt;simpleAppservingTomcat&lt;/i&gt; exposes in the &lt;i&gt;providesContainers&lt;/i&gt; attribute set, are automatically propagated as container parameters to the &lt;i&gt;GeolocationService&lt;/i&gt; Nix expression, so that it knows where the WAR file should be copied to, to automatically hot-deploy the service.&lt;br /&gt;&lt;br /&gt;If Disnix does not detect a service that provides a required container deployed to the same machine, then it will fall back to its original behaviour -- it automatically propagates the properties of a container in the infrastructure model, and assumes the the container service is already deployed by an infrastructure deployment solution.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Simplifications&lt;/h2&gt;&lt;br /&gt;The notation used for the &lt;i&gt;simpleAppservingTomcat&lt;/i&gt; service (shown earlier) refers to an attribute set. An attribute set also makes it possible to specify multiple container instances. However, it is far more common that we only need one single container instance.&lt;br /&gt;&lt;br /&gt;Moreover, there is some redundancy -- we need to specify certain properties in two places. Some properties can both belong to a service, as well as the container properties that we want to propagate to the services that require it.&lt;br /&gt;&lt;br /&gt;We can also use a shorter notation to expose only one single container:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;simpleAppservingTomcat = rec {&lt;br /&gt;  name = &quot;simpleAppservingTomcat&quot;;&lt;br /&gt;  pkg = constructors.simpleAppservingTomcat {&lt;br /&gt;    inherit httpPort;&lt;br /&gt;    commonLibs = [ &quot;${pkgs.mysql_jdbc}/share/java/mysql-connector-java.jar&quot; ];&lt;br /&gt;  };&lt;br /&gt;  httpPort = 8080;&lt;br /&gt;  catalinaBaseDir = &quot;/var/tomcat/webapps&quot;;&lt;br /&gt;  type = &quot;systemd-unit&quot;;&lt;br /&gt;  providesContainer = &quot;tomcat-webapplication&quot;;&lt;br /&gt;};&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, we have rewritten the service configuration of &lt;i&gt;simpleAppserviceTomcat&lt;/i&gt; to use the &lt;i&gt;providesContainer&lt;/i&gt; attribute referring to a string. This shorter notation will automatically expose all non-reserved service properties as container properties.&lt;br /&gt;&lt;br /&gt;For our example above, this means that it will automatically expose &lt;i&gt;httpPort&lt;/i&gt;, and &lt;i&gt;catalinaBaseDir&lt;/i&gt; and ignores the remaining properties -- these remaining properties have a specific purpose for the Disnix deployment system.&lt;br /&gt;&lt;br /&gt;Although the notation above simplifies things considerably, the above example still contains a bit of redundancy -- some of the container properties that we want to expose to application services, also need to be propagated to the constructor function requiring us to specify the same properties twice.&lt;br /&gt;&lt;br /&gt;We can eliminate this redundancy by encapsulating the creation of the service properties attribute set a constructor function. With a constructor function, we can simply write:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;simpleAppservingTomcat = constructors.simpleAppservingTomcat {&lt;br /&gt;  httpPort = 8080;&lt;br /&gt;  commonLibs = [ &quot;${pkgs.mysql_jdbc}/share/java/mysql-connector-java.jar&quot; ];&lt;br /&gt;  type = &quot;systemd-unit&quot;;&lt;br /&gt;};&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Example: deploying container and application services as one system&lt;/h2&gt;&lt;br /&gt;By applying the techniques described in the previous section to the StaffTracker example (e.g. distributing a &lt;i&gt;simpleAppservingTomcat&lt;/i&gt; and &lt;i&gt;mysql&lt;/i&gt; to the same machines that host Java web applications and MySQL databases), we can deploy the StaffTracker system including all its required container services with a single command-line instruction:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-env -s services-with-containers.nix \&lt;br /&gt;  -i infrastructure-bare.nix \&lt;br /&gt;  -d distribution-with-containers.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The corresponding deployment architecture visualization may look as follows:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-SCCzN8g3iHk/XqfyGdXiipI/AAAAAAAAKBw/MW2eE7eaj1w3Mm3AxNWiwGLjh0E9v5jewCLcBGAsYHQ/s1600/deploymentarch-combined.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://3.bp.blogspot.com/-SCCzN8g3iHk/XqfyGdXiipI/AAAAAAAAKBw/MW2eE7eaj1w3Mm3AxNWiwGLjh0E9v5jewCLcBGAsYHQ/s640/deploymentarch-combined.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As you may notice, the above diagram looks very similar to the previously shown deployment architecture diagram of the services layer.&lt;br /&gt;&lt;br /&gt;What has been added are the container services -- the ovals with the double borders denote services that are also container providers. The labels describe both the name of the service and the containers that it provides (behind the arrow &lt;i&gt;-&amp;gt;&lt;/i&gt;).&lt;br /&gt;&lt;br /&gt;Furthermore, all the services that are hosted inside a particular container environment (e.g. &lt;i&gt;tomcat-webapplication&lt;/i&gt;) have a local inter-dependency on the corresponding container provider service (e.g. &lt;i&gt;simpleAppservingTomcat&lt;/i&gt;), causing Disnix to activate Apache Tomcat before the web applications that are hosted inside it.&lt;br /&gt;&lt;br /&gt;Another thing you might notice, is that we have not completely eliminated the dependency on an infrastructure deployment solution -- the MySQL DBMS and Apache Tomcat service are deployed as &lt;i&gt;systemd-unit&lt;/i&gt; requiring the presence of systemd on the target system. Systemd should be provided as part of the target Linux distribution, and cannot be managed by Disnix because it runs as PID 1.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Example: deploying multiple container service instances and application services&lt;/h2&gt;&lt;br /&gt;One of my motivating reasons to use Disnix as a deployment solution for container services is to be able to deploy multiple instances of them to the same machine. This can also be done in a combined container and application services deployment approach.&lt;br /&gt;&lt;br /&gt;To allow, for example, to have two instance of Apache Tomcat to co-exist on one machine, we must configure them in such a way their resources do not conflict:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{ pkgs, system, distribution, invDistribution&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;systemd&quot;&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ../../../nix-processmgmt/examples/service-containers-agnostic/constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir cacheDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  simpleAppservingTomcat-primary = constructors.simpleAppservingTomcat {&lt;br /&gt;    instanceSuffix = &quot;-primary&quot;;&lt;br /&gt;    httpPort = 8080;&lt;br /&gt;    httpsPort = 8443;&lt;br /&gt;    serverPort = 8005;&lt;br /&gt;    ajpPort = 8009;&lt;br /&gt;    commonLibs = [ &quot;${pkgs.mysql_jdbc}/share/java/mysql-connector-java.jar&quot; ];&lt;br /&gt;    type = &quot;systemd-unit&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  simpleAppservingTomcat-secondary = constructors.simpleAppservingTomcat {&lt;br /&gt;    instanceSuffix = &quot;-secondary&quot;;&lt;br /&gt;    httpPort = 8081;&lt;br /&gt;    httpsPort = 8444;&lt;br /&gt;    serverPort = 8006;&lt;br /&gt;    ajpPort = 8010;&lt;br /&gt;    commonLibs = [ &quot;${pkgs.mysql_jdbc}/share/java/mysql-connector-java.jar&quot; ];&lt;br /&gt;    type = &quot;systemd-unit&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above partial services model defines two Apache Tomcat instances, that have been configured to listen to different TCP ports (for example the primary Tomcat instance listens to HTTP traffic on port 8080, whereas the secondary instance listens on port 8081), and serving web applications from a different deployment directories. Because their properties do not conflict, they can co-exist on the same machine.&lt;br /&gt;&lt;br /&gt;With the following distribution model, we can deploy multiple container providers to the same machine and distribute application services to them:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  # Container providers&lt;br /&gt;&lt;br /&gt;  mysql-primary = [ infrastructure.test1 ];&lt;br /&gt;  mysql-secondary = [ infrastructure.test1 ];&lt;br /&gt;  simpleAppservingTomcat-primary = [ infrastructure.test2 ];&lt;br /&gt;  simpleAppservingTomcat-secondary = [ infrastructure.test2 ];&lt;br /&gt;&lt;br /&gt;  # Application components&lt;br /&gt;&lt;br /&gt;  GeolocationService = {&lt;br /&gt;    targets = [&lt;br /&gt;      { target = infrastructure.test2;&lt;br /&gt;        container = &quot;tomcat-webapplication-primary&quot;;&lt;br /&gt;      }&lt;br /&gt;    ];&lt;br /&gt;  };&lt;br /&gt;  RoomService = {&lt;br /&gt;    targets = [&lt;br /&gt;      { target = infrastructure.test2;&lt;br /&gt;        container = &quot;tomcat-webapplication-secondary&quot;;&lt;br /&gt;      }&lt;br /&gt;    ];&lt;br /&gt;  };&lt;br /&gt;  StaffTracker = {&lt;br /&gt;    targets = [&lt;br /&gt;      { target = infrastructure.test2;&lt;br /&gt;        container = &quot;tomcat-webapplication-secondary&quot;;&lt;br /&gt;      }&lt;br /&gt;    ];&lt;br /&gt;  };&lt;br /&gt;  staff = {&lt;br /&gt;    targets = [&lt;br /&gt;      { target = infrastructure.test1;&lt;br /&gt;        container = &quot;mysql-database-secondary&quot;;&lt;br /&gt;      }&lt;br /&gt;    ];&lt;br /&gt;  };&lt;br /&gt;  zipcodes = {&lt;br /&gt;    targets = [&lt;br /&gt;      { target = infrastructure.test1;&lt;br /&gt;        container = &quot;mysql-database-primary&quot;;&lt;br /&gt;      }&lt;br /&gt;    ];&lt;br /&gt;  };&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the first four lines of the distribution model shown above, we distribute the container providers. As you may notice, we distribute two MySQL instances that should co-exist on machine &lt;i&gt;test1&lt;/i&gt; and two Apache Tomcat instances that should co-exist on machine &lt;i&gt;test2&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;In the remainder of the distribution model, we map Java web applications and MySQL databases to these container providers. As explained in the previous blog post about deploying multiple container service instances, if no container is specified in the distribution model, Disnix will auto map the service to the container that has the same name as the service's &lt;i&gt;type&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;In the above example, we have two instances of each container service with a different name. As a result, we need to use the more verbose notation for distribution mappings to instruct Disnix to which container provider we want to deploy the service.&lt;br /&gt;&lt;br /&gt;Deploying the system with the following command-line instruction:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-env -s services-with-multicontainers.nix \&lt;br /&gt;  -i infrastructure-bare.nix \&lt;br /&gt;  -d distribution-with-multicontainers.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;results in a running system that may has the following deployment architecture:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-kn5TjiUpuT4/XqgAf1M9r_I/AAAAAAAAKB8/CBkVKFmlu_YbUWeedLVLWQvwgiMgyaVoQCLcBGAsYHQ/s1600/deploymentarch-multicontainers.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-kn5TjiUpuT4/XqgAf1M9r_I/AAAAAAAAKB8/CBkVKFmlu_YbUWeedLVLWQvwgiMgyaVoQCLcBGAsYHQ/s640/deploymentarch-multicontainers.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As you may notice, we have MySQL databases and Java web application distributed over mutiple container providers residing on the same machine. All services belong to the same system, deployed by a single Disnix command.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;A more extreme example: multiple process managers&lt;/h2&gt;&lt;br /&gt;By exposing services as container providers in Disnix, my original requirements were met. Because the facilities are very flexible, I also discovered that there is much more I could do.&lt;br /&gt;&lt;br /&gt;For example, on more primitive systems that do not have systemd, I could also extend the services and distribution models in such a way that I can deploy supervisord as a process manager first (as a &lt;i&gt;sysvinit-script&lt;/i&gt; that does not require any process manager service), then use supervisord to manage MySQL and Apache Tomcat, and then use the Dysnomia plugin system to deploy the databases and Java web applications to these container services managed by supervisord:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-SnxhfSHR7ZI/XqgXfmpV9uI/AAAAAAAAKCI/bepnVXFy09I42Dt_-t5wur-QWdb4-DJRACLcBGAsYHQ/s1600/deploymentarch-extreme.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://3.bp.blogspot.com/-SnxhfSHR7ZI/XqgXfmpV9uI/AAAAAAAAKCI/bepnVXFy09I42Dt_-t5wur-QWdb4-DJRACLcBGAsYHQ/s640/deploymentarch-extreme.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As you may notice, the deployment architecture above looks similar to the first combined deployment example, with &lt;i&gt;supervisord&lt;/i&gt; added as an extra container provider service.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;More efficient reuse: expose any kind of service as container provider&lt;/h2&gt;&lt;br /&gt;In addition to managed processes (which the MySQL DBMS and Apache Tomcat services are), any kind of Disnix service can act as a container provider.&lt;br /&gt;&lt;br /&gt;An example of such a non-process managed container provider could be &lt;a href=&quot;http://axis.apache.org/axis2&quot;&gt;Apache Axis2&lt;/a&gt;. In the StaffTracker example, all data access is provided by web services. These web services are implemented as Java web applications (WAR files) embedding an Apache Axis2 container that embeds an Axis2 Application Archive (AAR file) providing the web service implementation.&lt;br /&gt;&lt;br /&gt;Every web application that is a web service includes its own implementation of Apache Axis2.&lt;br /&gt;&lt;br /&gt;It is also possible to deploy a single Axis2 web application to Apache Tomcat, and treat each Axis2 Application Archive as a separate deployment unit using the &lt;i&gt;axis2-webservice&lt;/i&gt; identifier as a container provider for any service of the type: &lt;i&gt;axis2-webservice&lt;/i&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{ pkgs, system, distribution, invDistribution&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;systemd&quot;&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ../../../nix-processmgmt/examples/service-containers-agnostic/constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir cacheDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  customPkgs = import ../top-level/all-packages.nix {&lt;br /&gt;    inherit system pkgs stateDir;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;### Container providers&lt;br /&gt;&lt;br /&gt;  simpleAppservingTomcat = constructors.simpleAppservingTomcat {&lt;br /&gt;    httpPort = 8080;&lt;br /&gt;    commonLibs = [ &quot;${pkgs.mysql_jdbc}/share/java/mysql-connector-java.jar&quot; ];&lt;br /&gt;    type = &quot;systemd-unit&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  axis2 = customPkgs.axis2 {};&lt;br /&gt;&lt;br /&gt;### Web services&lt;br /&gt;&lt;br /&gt;  HelloService = {&lt;br /&gt;    name = &quot;HelloService&quot;;&lt;br /&gt;    pkg = customPkgs.HelloService;&lt;br /&gt;    dependsOn = {};&lt;br /&gt;    type = &quot;axis2-webservice&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  HelloWorldService = {&lt;br /&gt;    name = &quot;HelloWorldService&quot;;&lt;br /&gt;    pkg = customPkgs.HelloWorldService;&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit HelloService;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;axis2-webservice&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above partial services model, we have defined two container providers:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;i&gt;simpleAppservingTomcat&lt;/i&gt; that provides a Servlet container in which Java web applications (WAR files) can be hosted.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;axis2&lt;/i&gt; service is a Java web application that acts as a container provider for Axis2 web services.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The remaining services are Axis2 web services that can be embedded inside the shared Axis2 container.&lt;br /&gt;&lt;br /&gt;If we deploy the above example system, e.g.:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ disnix-env -s services-optimised.nix \&lt;br /&gt;  -i infrastructure-bare.nix \&lt;br /&gt;  -d distribution-optimised.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;may result in the following deployment architecture:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-5bpdPjW4BWg/Xqgw2C4e6nI/AAAAAAAAKCU/wxjonZMdIio-BBWWJB5PRb0PzM4V-W1agCLcBGAsYHQ/s1600/deploymentarch-optimised.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-5bpdPjW4BWg/Xqgw2C4e6nI/AAAAAAAAKCU/wxjonZMdIio-BBWWJB5PRb0PzM4V-W1agCLcBGAsYHQ/s640/deploymentarch-optimised.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As may be observed when looking at the above architecture diagram, the web services deployed to the &lt;i&gt;test2&lt;/i&gt; machine, use a shared Axis2 container, that is embedded as a Java web application inside Apache Tomcat.&lt;br /&gt;&lt;br /&gt;The above system has a far better degree of reuse, because it does not use redundant copies of Apache Axis2 for each web service.&lt;br /&gt;&lt;br /&gt;Although it is possible to have a deployment architecture with a shared Axis2 container, this shared approach is not always desirable to use. For example, database connections managed by Apache Tomcat are shared between all web services embedded in an Axis2 container, which is not always desirable from a security point of view.&lt;br /&gt;&lt;br /&gt;Moreover, an unstable web service embedded in an Axis2 container might also tear the container down causing the other web services to crash as well. Still, the deployment system does not make it difficult to use a shared approach, when it is desired.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;With this new feature addition to Disnix, that can expose services as container providers, it becomes possible to deploy both container services and application services as one integrated system.&lt;br /&gt;&lt;br /&gt;Furthermore, it also makes it possible to:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Deploy multiple instances of container services and deploy services to them.&lt;/li&gt;&lt;li&gt;For process-based service containers, we can combine the process manager-agostic framework described in the previous blog post, so that we can use them with any process manager on any operating system that it supports.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The fact that Disnix can now also deploy containers does not mean that it no longer relies on external infrastructure deployment solutions anymore. For example, you still need target machines at your disposal that have Nix and Disnix installed and need to be remotely connectable, e.g. through SSH. For this, you still require an external infrastructure deployment solution, such as NixOps.&lt;br /&gt;&lt;br /&gt;Furthermore, not all container services can be managed by Disnix. For example, systemd, that runs as a system's PID 1, cannot be installed by Disnix. Instead, it must already be provided by the target system's Linux distribution (In NixOS' case it is Nix that deploys it, but it is not managed by Disnix).&lt;br /&gt;&lt;br /&gt;And there may also be other reasons why you may still want to use separated deployment processes for container and service deployment. For example, you may want to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/10/deploying-net-services-with-disnix.html&quot;&gt;deploy to container services that cannot be managed by Nix/Disnix&lt;/a&gt;, or you may work in an organization in which two different teams take care of the infrastructure and the services.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The new features described in this blog post are part of the current development versions of Dysnomia and Disnix that can be obtained from &lt;a href=&quot;http://github.com/svanderburg&quot;&gt;my GitHub page&lt;/a&gt;. These features will become generally available in the next release.&lt;br /&gt;&lt;br /&gt;Moreover, I have extended all my public Disnix examples with container deployment support (including the Java-based StaffTracker and composition examples shown in this blog post). These changes currently reside in the &lt;i&gt;servicesascontainers&lt;/i&gt; Git branches.&lt;br /&gt;&lt;br /&gt;The &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;nix-processmgmt&lt;/a&gt; repository contains shared constructor functions for all kinds of system services, e.g. MySQL, Apache HTTP server, PostgreSQL and Apache Tomcat. These functions can be reused amongst all kinds of Disnix projects.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 30 Apr 2020 20:39:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Craige McWhirter: Building Daedalus Flight on NixOS</title>
	<guid isPermaLink="true">http://mcwhirter.com.au//craige/blog/2020/Building_Daedalus_Flight_on_NixOS/</guid>
	<link>http://mcwhirter.com.au//craige/blog/2020/Building_Daedalus_Flight_on_NixOS/</link>
	<description>&lt;p&gt;&lt;img alt=&quot;NixOS Daedalus Gears by Craige McWhirter&quot; src=&quot;http://mcwhirter.com.au/files/NixOS_Daedalus_Gears.png&quot; title=&quot;NixOS Daedalus Gears by Craige McWhirter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://daedaluswallet.io/en/flight/&quot;&gt;Daedalus Flight&lt;/a&gt; was recently released
and this is how you can build and run this version of
&lt;a href=&quot;https://daedaluswallet.io/&quot;&gt;Deadalus&lt;/a&gt; on &lt;a href=&quot;https://nixos.org/&quot;&gt;NixOS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you want to speed the build process up, you can add the
&lt;a href=&quot;https://iohk.io/&quot;&gt;IOHK&lt;/a&gt; &lt;a href=&quot;https://nixos.org/nix/&quot;&gt;Nix&lt;/a&gt; cache to your own NixOS configuration:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.mcwhirter.io/craige/mio-ops/src/branch/master/roles/iohk.nix&quot;&gt;iohk.nix&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;nix&quot;&gt;nix.binaryCaches = [
  &quot;https://cache.nixos.org&quot;
  &quot;https://hydra.iohk.io&quot;
];
nix.binaryCachePublicKeys = [
  &quot;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&quot;
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you haven't already, you can clone the &lt;a href=&quot;https://github.com/input-output-hk/daedalus&quot;&gt;Daedalus
repo&lt;/a&gt; and specifically the
1.0.0 tagged commit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --branch 1.0.0 https://github.com/input-output-hk/daedalus.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you've cloned the repo and checked you're on the 1.0.0 tagged commit,
you can build Daedalus flight with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nix build -f . daedalus --argstr cluster mainnet_flight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the build completes, you're ready to launch Daedalus Flight:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./result/bin/daedalus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify that you have in fact built Daedalus Flight, first head to the
&lt;code&gt;Daedalus&lt;/code&gt; menu then &lt;code&gt;About Daedalus&lt;/code&gt;. You should see a title such as
&quot;DAEDALUS 1.0.0&quot;. The second check, is to press &lt;code&gt;[Ctl]+d&lt;/code&gt; to access &lt;code&gt;Daedalus
Diagnostocs&lt;/code&gt; and your &lt;code&gt;Daedalus state directory&lt;/code&gt; should have &lt;code&gt;mainnet_flight&lt;/code&gt;
at the end of the path.&lt;/p&gt;

&lt;p&gt;If you've got these, give yourself a pat on the back and grab yourself a
refreshing bevvy while you wait for blocks to sync.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Daedalus FC1 screenshot&quot; src=&quot;http://mcwhirter.com.au/files/Daedalus_FC1.png&quot; title=&quot;Daedalus FC1 screenshot&quot; /&gt;&lt;/p&gt;</description>
	<pubDate>Thu, 23 Apr 2020 23:28:59 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: Binary Cache Support</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-04-18-binary-cache-support.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-04-18-binary-cache-support.html</link>
	<description>&lt;p&gt;Up until now, nixbuild.net has not supported directly fetching build dependencies from binary caches like &lt;a href=&quot;https://cache.nixos.org&quot;&gt;cache.nixos.org&lt;/a&gt; or &lt;a href=&quot;https://cachix.org&quot;&gt;Cachix&lt;/a&gt;. All build dependencies have instead been uploaded from the user’s local machine to nixbuild.net the first time they’ve been needed.&lt;/p&gt;
&lt;p&gt;Today, this bottleneck has been removed, since nixbuild.net now can fetch build dependencies directly from binary caches, without taxing users’ upload bandwidth.&lt;/p&gt;

&lt;p&gt;By default, the official Nix binary cache (&lt;a href=&quot;https://cache.nixos.org&quot;&gt;cache.nixos.org&lt;/a&gt;) is added to all nixbuild.net accounts, but a nixbuild.net user can freely decide on which caches that should be queried for build dependencies (including &lt;a href=&quot;https://cachix.org&quot;&gt;Cachix&lt;/a&gt; caches).&lt;/p&gt;
&lt;p&gt;An additional benefit of the new support for binary caches is that users that trust the same binary caches automatically share build dependencies from those caches. This means that if one user’s build has triggered a download from for example cache.nixos.org, the next user that comes along and needs the same build dependency doesn’t have to spend time on downloading that dependency.&lt;/p&gt;
&lt;p&gt;For more information on how to use binary caches with nixbuild.net, see the &lt;a href=&quot;https://docs.nixbuild.net/getting-started/&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;</description>
	<pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Graham Christensen: Erase your darlings</title>
	<guid isPermaLink="false">http://grahamc.com//blog/erase-your-darlings</guid>
	<link>http://grahamc.com/blog/erase-your-darlings</link>
	<description>&lt;p&gt;I erase my systems at every boot.&lt;/p&gt;

&lt;p&gt;Over time, a system collects state on its root partition. This state
lives in assorted directories like &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;, and represents
every under-documented or out-of-order step in bringing up the
services.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Right, run &lt;code class=&quot;highlighter-rouge&quot;&gt;myapp-init&lt;/code&gt;.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;These small, inconsequential “oh, oops” steps are the pieces that get
lost and don’t appear in your runbooks.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Just download ca-certificates to … to fix …”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each of these quick fixes leaves you doomed to repeat history in three
years when you’re finally doing that dreaded RHEL 7 to RHEL 8 upgrade.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Oh, &lt;code class=&quot;highlighter-rouge&quot;&gt;touch /etc/ipsec.secrets&lt;/code&gt; or the l2tp tunnel won’t work.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;immutable-infrastructure-gets-us-so-close&quot;&gt;Immutable infrastructure gets us &lt;em&gt;so&lt;/em&gt; close&lt;/h3&gt;

&lt;p&gt;Immutable infrastructure is a wonderfully effective method of
eliminating so many of these forgotten steps. Leaning in to the pain
by deleting and replacing your servers on a weekly or monthly basis
means you are constantly testing and exercising your automation and
runbooks.&lt;/p&gt;

&lt;p&gt;The nugget here is the regular and indiscriminate removal of system
state. Destroying the whole server doesn’t leave you much room to
forget the little tweaks you made along the way.&lt;/p&gt;

&lt;p&gt;These techniques work great when you meet two requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;you can provision and destroy servers with an API call&lt;/li&gt;
  &lt;li&gt;the servers aren’t inherently stateful&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;long-running-servers&quot;&gt;Long running servers&lt;/h4&gt;

&lt;p&gt;There are lots of cases in which immutable infrastructure &lt;em&gt;doesn’t&lt;/em&gt;
work, and the dirty secret is &lt;strong&gt;those servers need good tools the
most.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Long-running servers cause long outages. Their runbooks are outdated
and incomplete. They accrete tweaks and turn in to an ossified,
brittle snowflake — except its arms are load-bearing.&lt;/p&gt;

&lt;p&gt;Let’s bring the ideas of immutable infrastructure to these systems
too. Whether this system is embedded in a stadium’s jumbotron, in a
datacenter, or under your desk, we &lt;em&gt;can&lt;/em&gt; keep the state under control.&lt;/p&gt;

&lt;h4 id=&quot;fhs-isnt-enough&quot;&gt;FHS isn’t enough&lt;/h4&gt;

&lt;p&gt;The hard part about applying immutable techniques to long running
servers is knowing exactly where your application state ends and the
operating system, software, and configuration begin.&lt;/p&gt;

&lt;p&gt;This is hard because legacy operating systems and the Filesystem
Hierarchy Standard poorly separate these areas of concern. For
example, &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib&lt;/code&gt; is for state information, but how much of this do
you actually care about tracking? What did you configure in &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; on
purpose?&lt;/p&gt;

&lt;p&gt;The answer is probably not a lot.&lt;/p&gt;

&lt;p&gt;You may not care, but all of this accumulation of junk is a tarpit.
Everything becomes harder: replicating production, testing changes,
undoing mistakes.&lt;/p&gt;

&lt;h3 id=&quot;new-computer-smell&quot;&gt;New computer smell&lt;/h3&gt;

&lt;p&gt;Getting a new computer is this moment of cleanliness. The keycaps
don’t have oils on them, the screen is perfect, and the hard drive
is fresh and unspoiled — for about an hour or so.&lt;/p&gt;

&lt;p&gt;Let’s get back to that.&lt;/p&gt;

&lt;h2 id=&quot;how-is-this-possible&quot;&gt;How is this possible?&lt;/h2&gt;

&lt;p&gt;NixOS can boot with only two directories: &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt; contains read-only system configurations, which are specified
by your &lt;code class=&quot;highlighter-rouge&quot;&gt;configuration.nix&lt;/code&gt; and are built and tracked as system
generations. These never change. Once the files are created in &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt;,
the only way to change the config’s contents is to build a new system
configuration with the contents you want.&lt;/p&gt;

&lt;p&gt;Any configuration or files created on the drive outside of &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt; is
state and cruft. We can lose everything outside of &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt;
and have a healthy system. My technique is to explicitly opt in and
&lt;em&gt;choose&lt;/em&gt; which state is important, and only keep that.&lt;/p&gt;

&lt;p&gt;How this is possible comes down to the boot sequence.&lt;/p&gt;

&lt;p&gt;For NixOS, the bootloader follows the same basic steps as a standard
Linux distribution: the kernel starts with an initial ramdisk, and the
initial ramdisk mounts the system disks.&lt;/p&gt;

&lt;p&gt;And here is where the similarities end.&lt;/p&gt;

&lt;h3 id=&quot;nixoss-early-startup&quot;&gt;NixOS’s early startup&lt;/h3&gt;

&lt;p&gt;NixOS configures the bootloader to pass some extra information: a
specific system configuration. This is the secret to NixOS’s
bootloader rollbacks, and also the key to erasing our disk on each
boot. The parameter is named &lt;code class=&quot;highlighter-rouge&quot;&gt;systemConfig&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On every startup the very early boot stage knows what the system’s
configuration should be: the entire system configuration is stored in
the read-only &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix/store&lt;/code&gt;, and the directory passed through
&lt;code class=&quot;highlighter-rouge&quot;&gt;systemConfig&lt;/code&gt; has a reference to the config. Early boot then
manipulates &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;/run&lt;/code&gt; to match the chosen setup. Usually this
involves swapping out a few symlinks.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; simply doesn’t exist, however, early boot &lt;em&gt;creates&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;
and moves on like it were any other boot. It also &lt;em&gt;creates&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;, and any other core directories that must be present.&lt;/p&gt;

&lt;p&gt;Simply speaking, an empty &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; is &lt;em&gt;not surprising&lt;/em&gt; to NixOS. In fact,
the NixOS netboot, EC2, and installation media all start out this way.&lt;/p&gt;

&lt;h2 id=&quot;opting-out&quot;&gt;Opting out&lt;/h2&gt;

&lt;p&gt;Before we can opt in to saving data, we must opt out of saving data
&lt;em&gt;by default&lt;/em&gt;. I do this by setting up my filesystem in a way that
lets me easily and safely erase the unwanted data, while preserving
the data I do want to keep.&lt;/p&gt;

&lt;p&gt;My preferred method for this is using a ZFS dataset and rolling it
back to a blank snapshot before it is mounted. A partition of any
other filesystem would work just as well too, running &lt;code class=&quot;highlighter-rouge&quot;&gt;mkfs&lt;/code&gt; at boot,
or something similar. If you have a lot of RAM, you could skip the
erase step and make &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; a tmpfs.&lt;/p&gt;

&lt;h3 id=&quot;opting-out-with-zfs&quot;&gt;Opting out with ZFS&lt;/h3&gt;
&lt;p&gt;When installing NixOS, I partition my disk with two partitions, one
for the boot partition, and another for a ZFS pool. Then I create and
mount a few datasets.&lt;/p&gt;

&lt;p&gt;My root dataset:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# zfs create -p -o mountpoint=legacy rpool/local/root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Before I even mount it, I &lt;strong&gt;create a snapshot while it is totally
blank&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# zfs snapshot rpool/local/root@blank
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then mount it:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mount -t zfs rpool/local/root /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then I mount the partition I created for the &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir /mnt/boot
# mount /dev/the-boot-partition /mnt/boot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Create and mount a dataset for &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# zfs create -p -o mountpoint=legacy rpool/local/nix
# mkdir /mnt/nix
# mount -t zfs rpool/local/nix /mnt/nix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And a dataset for &lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# zfs create -p -o mountpoint=legacy rpool/safe/home
# mkdir /mnt/home
# mount -t zfs rpool/safe/home /mnt/home
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally, a dataset explicitly for state I want to persist between
boots:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# zfs create -p -o mountpoint=legacy rpool/safe/persist
# mkdir /mnt/persist
# mount -t zfs rpool/safe/persist /mnt/persist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; in my systems, datasets under &lt;code class=&quot;highlighter-rouge&quot;&gt;rpool/local&lt;/code&gt; are never backed
up, and datasets under &lt;code class=&quot;highlighter-rouge&quot;&gt;rpool/safe&lt;/code&gt; are.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And now safely erasing the root dataset on each boot is very easy:
after devices are made available, roll back to the blank snapshot:&lt;/p&gt;

&lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;boot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;initrd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;postDeviceCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mkAfter&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    zfs rollback -r rpool/local/root@blank&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  ''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I then finish the installation as normal. If all goes well, your
next boot will start with an empty root partition but otherwise be
configured exactly as you specified.&lt;/p&gt;

&lt;h2 id=&quot;opting-in&quot;&gt;Opting in&lt;/h2&gt;

&lt;p&gt;Now that I’m keeping no state, it is time to specify what I do want
to keep. My choices here are different based on the role of the
system: a laptop has different state than a server.&lt;/p&gt;

&lt;p&gt;Here are some different pieces of state and how I preserve them. These
examples largely use reconfiguration or symlinks, but using ZFS
datasets and mount points would work too.&lt;/p&gt;

&lt;h4 id=&quot;wireguard-private-keys&quot;&gt;Wireguard private keys&lt;/h4&gt;

&lt;p&gt;Create a directory under &lt;code class=&quot;highlighter-rouge&quot;&gt;/persist&lt;/code&gt; for the key:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir -p /persist/etc/wireguard/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And use Nix’s wireguard module to generate the key there:&lt;/p&gt;

&lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;networking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;wireguard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;interfaces&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;wg0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;generatePrivateKeyFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;privateKeyFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/persist/etc/wireguard/wg0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;networkmanager-connections&quot;&gt;NetworkManager connections&lt;/h4&gt;

&lt;p&gt;Create a directory under &lt;code class=&quot;highlighter-rouge&quot;&gt;/persist&lt;/code&gt;, mirroring the &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; structure:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir -p /persist/etc/NetworkManager/system-connections
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And use Nix’s &lt;code class=&quot;highlighter-rouge&quot;&gt;etc&lt;/code&gt; module to set up the symlink:&lt;/p&gt;

&lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;NetworkManager/system-connections&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/persist/etc/NetworkManager/system-connections/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;bluetooth-devices&quot;&gt;Bluetooth devices&lt;/h4&gt;

&lt;p&gt;Create a directory under &lt;code class=&quot;highlighter-rouge&quot;&gt;/persist&lt;/code&gt;, mirroring the &lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt; structure:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir -p /persist/var/lib/bluetooth
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then use systemd’s tmpfiles.d rules to create a symlink from
&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/bluetooth&lt;/code&gt; to my persisted directory:&lt;/p&gt;

&lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;systemd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tmpfiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;L /var/lib/bluetooth - - - - /persist/var/lib/bluetooth&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ssh-host-keys&quot;&gt;SSH host keys&lt;/h4&gt;

&lt;p&gt;Create a directory under &lt;code class=&quot;highlighter-rouge&quot;&gt;/persist&lt;/code&gt;, mirroring the &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; structure:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir -p /persist/etc/ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And use Nix’s openssh module to create and use the keys in that
directory:&lt;/p&gt;

&lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;openssh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;hostKeys&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/persist/ssh/ssh_host_ed25519_key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ed25519&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/persist/ssh/ssh_host_rsa_key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;rsa&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;acme-certificates&quot;&gt;ACME certificates&lt;/h4&gt;

&lt;p&gt;Create a directory under &lt;code class=&quot;highlighter-rouge&quot;&gt;/persist&lt;/code&gt;, mirroring the &lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt; structure:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir -p /persist/var/lib/acme
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then use systemd’s tmpfiles.d rules to create a symlink from
&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/acme&lt;/code&gt; to my persisted directory:&lt;/p&gt;

&lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;systemd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tmpfiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;L /var/lib/acme - - - - /persist/var/lib/acme&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;answering-the-question-what-am-i-about-to-lose&quot;&gt;Answering the question “what am I about to lose?”&lt;/h3&gt;

&lt;p&gt;I found this process a bit scary for the first few weeks: was I losing
important data each reboot? No, I wasn’t.&lt;/p&gt;

&lt;p&gt;If you’re worried and want to know what state you’ll lose on the next
boot, you can list the files on your root filesystem and see if you’re
missing something important:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tree -x /
├── bin
│   └── sh -&amp;gt; /nix/store/97zzcs494vn5k2yw-dash-0.5.10.2/bin/dash
├── boot
├── dev
├── etc
│   ├── asound.conf -&amp;gt; /etc/static/asound.conf
... snip ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ZFS can give you a similar answer:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# zfs diff rpool/local/root@blank
M	/
+	/nix
+	/etc
+	/root
+	/var/lib/is-nix-channel-up-to-date
+	/etc/pki/fwupd
+	/etc/pki/fwupd-metadata
... snip ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;your-stateless-future&quot;&gt;Your stateless future&lt;/h2&gt;

&lt;p&gt;You may bump in to new state you meant to be preserving. When I’m
adding new services, I think about the state it is writing and whether
I care about it or not. If I care, I find a way to redirect its state
to &lt;code class=&quot;highlighter-rouge&quot;&gt;/persist&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Take care to reboot these machines on a somewhat regular basis. It
will keep things agile, proving your system state is tracked
correctly.&lt;/p&gt;

&lt;p&gt;This technique has given me the “new computer smell” on every boot
without the datacenter full of hardware, and even on systems that do
carry important state. I have deployed this strategy to systems in the
large and small: build farm servers, database servers, my NAS and home
server, my raspberry pi garage door opener, and laptops.&lt;/p&gt;

&lt;p&gt;NixOS enables powerful new deployment models in so many ways, allowing
for systems of all shapes and sizes to be managed properly and
consistently. I think this model of ephemeral roots is yet
another example of this flexibility and power. I would like to see
this partitioning scheme become a reference architecture and take us
out of this eternal tarpit of legacy.&lt;/p&gt;</description>
	<pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Graham Christensen: ZFS Datasets for NixOS</title>
	<guid isPermaLink="false">http://grahamc.com//blog/nixos-on-zfs</guid>
	<link>http://grahamc.com/blog/nixos-on-zfs</link>
	<description>&lt;p&gt;The outdated and historical nature of the &lt;a href=&quot;https://grahamc.com/feed/fhs&quot;&gt;Filesystem Hierarchy
Standard&lt;/a&gt; means traditional Linux distributions have to go to great
lengths to separate “user data” from “system data.”&lt;/p&gt;

&lt;p&gt;NixOS’s filesystem architecture does cleanly separate user data from
system data, and has a much easier job to do.&lt;/p&gt;

&lt;h3 id=&quot;traditional-linuxes&quot;&gt;Traditional Linuxes&lt;/h3&gt;

&lt;p&gt;Because FHS mixes these two concerns across the entire hierarchy,
splitting these concerns requires identifying every point across
dozens of directories where the data is the system’s or the user’s.
When adding ZFS to the mix, the installers typically have to create
over a dozen datasets to accomplish this.&lt;/p&gt;

&lt;p&gt;For example, Ubuntu’s upcoming ZFS support creates 16 datasets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-tree&quot;&gt;rpool/
├── ROOT
│   └── ubuntu_lwmk7c
│       ├── log
│       ├── mail
│       ├── snap
│       ├── spool
│       ├── srv
│       ├── usr
│       │   └── local
│       ├── var
│       │   ├── games
│       │   └── lib
│       │       ├── AccountServices
│       │       ├── apt
│       │       ├── dpkg
│       │       └── NetworkManager
│       └── www
└── USERDATA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going through the great pains of separating this data comes with
significant advantages: a recursive snapshot at any point in the tree
will create an atomic, point-in-time snapshot of every dataset below.&lt;/p&gt;

&lt;p&gt;This means in order to create a consistent snapshot of the system
data, an administrator would only need to take a recursive snapshot
at &lt;code class=&quot;highlighter-rouge&quot;&gt;ROOT&lt;/code&gt;. The same is true for user data: take a recursive snapshot of
&lt;code class=&quot;highlighter-rouge&quot;&gt;USERDATA&lt;/code&gt; and all user data is saved.&lt;/p&gt;

&lt;h3 id=&quot;nixos&quot;&gt;NixOS&lt;/h3&gt;

&lt;p&gt;Because Nix stores all of its build products in &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix/store&lt;/code&gt;, NixOS
doesn’t mingle these two concerns. NixOS’s runtime system, installed
packages, and rollback targets are all stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;User data is not.&lt;/p&gt;

&lt;p&gt;This removes the entire complicated tree of datasets to facilitate
FHS, and leaves us with only a few needed datasets.&lt;/p&gt;

&lt;h2 id=&quot;datasets&quot;&gt;Datasets&lt;/h2&gt;

&lt;p&gt;Design for the atomic, recursive snapshots when laying out the
datasets.&lt;/p&gt;

&lt;p&gt;In particular, I don’t back up the &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt; directory. This entire
directory can always be rebuilt later from the system’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration.nix&lt;/code&gt;, and isn’t worth the space.&lt;/p&gt;

&lt;p&gt;One way to model this might be splitting up the data into three
top-level datasets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-tree&quot;&gt;tank/
├── local
│   └── nix
├── system
│   └── root
└── user
    └── home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;tank/local&lt;/code&gt;, I would store datasets that should almost never be
snapshotted or backed up. &lt;code class=&quot;highlighter-rouge&quot;&gt;tank/system&lt;/code&gt; would store data that I would
want periodic snapshots for. Most importantly, &lt;code class=&quot;highlighter-rouge&quot;&gt;tank/user&lt;/code&gt; would
contain data I want regular snapshots and backups for, with a long
retention policy.&lt;/p&gt;

&lt;p&gt;From here, you could add a ZFS dataset per user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-tree&quot;&gt;tank/
├── local
│   └── nix
├── system
│   └── root
└── user
    └── home
        ├── grahamc
        └── gustav
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or a separate dataset for &lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-tree&quot;&gt;tank/
├── local
│   └── nix
├── system
│   ├── var
│   └── root
└── user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Importantly, this gives you three buckets for independent and
regular snapshots.&lt;/p&gt;

&lt;p&gt;The important part is having &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt; under its own top-level dataset.
This makes it a “cousin” to the data you &lt;em&gt;do&lt;/em&gt; want backup coverage on,
making it easier to take deep, recursive snapshots atomically.&lt;/p&gt;

&lt;h2 id=&quot;properties&quot;&gt;Properties&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Enable compression with &lt;code class=&quot;highlighter-rouge&quot;&gt;compression=on&lt;/code&gt;. Specifying &lt;code class=&quot;highlighter-rouge&quot;&gt;on&lt;/code&gt; instead of
&lt;code class=&quot;highlighter-rouge&quot;&gt;lz4&lt;/code&gt; or another specific algorithm will always pick the best
available compression algorithm.&lt;/li&gt;
  &lt;li&gt;The dataset containing journald’s logs (where &lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt; lives) should
have &lt;code class=&quot;highlighter-rouge&quot;&gt;xattr=sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;acltype=posixacl&lt;/code&gt; set to allow regular users to
read their journal.&lt;/li&gt;
  &lt;li&gt;Nix doesn’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;atime&lt;/code&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;atime=off&lt;/code&gt; on the &lt;code class=&quot;highlighter-rouge&quot;&gt;/nix&lt;/code&gt; dataset is
fine.&lt;/li&gt;
  &lt;li&gt;NixOS requires (as of 2020-04-11) &lt;code class=&quot;highlighter-rouge&quot;&gt;mountpoint=legacy&lt;/code&gt; for all
datasets. NixOS does not yet have tooling to require implicitly
created ZFS mounts to settle before booting, and &lt;code class=&quot;highlighter-rouge&quot;&gt;mountpoint=legacy&lt;/code&gt;
plus explicit mount points in &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware-configuration.nix&lt;/code&gt; will
ensure all your datasets are mounted at the right time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I don’t know how to pick &lt;code class=&quot;highlighter-rouge&quot;&gt;ashift&lt;/code&gt;, and usually just allow ZFS to guess
on my behalf.&lt;/p&gt;

&lt;h2 id=&quot;partitioning&quot;&gt;Partitioning&lt;/h2&gt;

&lt;p&gt;I only create two partitions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt; formatted &lt;code class=&quot;highlighter-rouge&quot;&gt;vfat&lt;/code&gt; for EFI, or &lt;code class=&quot;highlighter-rouge&quot;&gt;ext4&lt;/code&gt; for BIOS&lt;/li&gt;
  &lt;li&gt;The ZFS dataset partition.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are spooky articles saying only give ZFS entire disks. The
truth is, you shouldn’t split a disk into two active partitions.
Splitting the disk this way is just fine, since &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt; is rarely
read or written.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; If you do partition the disk, make sure you set the disk’s
scheduler to &lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;. ZFS takes this step automatically if it does
control the entire disk.&lt;/p&gt;

  &lt;p&gt;On NixOS, you an set your scheduler to &lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt; via:&lt;/p&gt;

  &lt;div class=&quot;language-nix highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;boot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;kernelParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;elevator=none&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;clean-isolation&quot;&gt;Clean isolation&lt;/h1&gt;

&lt;p&gt;NixOS’s clean separation of concerns reduces the amount of complexity
we need to track when considering and planning our datasets. This
gives us flexibility later, and enables some superpowers like erasing
my computer on every boot, which I’ll write about on Monday.&lt;/p&gt;</description>
	<pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: New nixbuild.net Resources</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-03-27-nixbuild-net-beta.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-03-27-nixbuild-net-beta.html</link>
	<description>&lt;p&gt;On the support side of the nixbuild.net service, two new resources have been published:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.nixbuild.net&quot;&gt;docs.nixbuild.net&lt;/a&gt;, collecting all available documentation for nixbuild.net users.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&quot;https://github.com/nixbuild/feedback&quot;&gt;nixbuild.net feedback&lt;/a&gt; repository on GitHub, providing a way to report issues or ask questions related to the service.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These resources are mainly useful for nixbuild.net beta users, but they are open to anyone. And anyone is of course welcome to request a free beta account for evaluating nixbuild.net, by just &lt;a href=&quot;mailto:rickard@nixbuild.net&quot;&gt;sending me an email&lt;/a&gt;.&lt;/p&gt;</description>
	<pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>

</channel>
</rss>
